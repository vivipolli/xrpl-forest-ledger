{"version":3,"file":"utils.test.js","sourceRoot":"","sources":["../src/utils.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { concatSig, padWithZeroes, normalize } from './utils';\n\ndescribe('padWithZeroes', function () {\n  it('pads a string shorter than the target length with zeroes', function () {\n    const input = 'abc';\n    expect(padWithZeroes(input, 5)).toBe(`00${input}`);\n  });\n\n  it('pads an empty string', function () {\n    const input = '';\n    expect(padWithZeroes(input, 4)).toBe(`0000`);\n  });\n\n  it('returns a string equal to the target length without modifying it', function () {\n    const input = 'abc';\n    expect(padWithZeroes(input, 3)).toStrictEqual(input);\n  });\n\n  it('returns a string longer than the target length without modifying it', function () {\n    const input = 'abcd';\n    expect(padWithZeroes(input, 3)).toStrictEqual(input);\n  });\n\n  it('throws an error if passed an invalid hex string', function () {\n    const inputs = ['0xabc', 'xyz', '-'];\n    for (const input of inputs) {\n      expect(() => padWithZeroes(input, 3)).toThrow(\n        new Error(`Expected an unprefixed hex string. Received: ${input}`),\n      );\n    }\n  });\n\n  it('throws an error if passed a negative number', function () {\n    expect(() => padWithZeroes('abc', -1)).toThrow(\n      new Error('Expected a non-negative integer target length. Received: -1'),\n    );\n  });\n});\n\ndescribe('concatSig', function () {\n  it('should concatenate an extended ECDSA signature', function () {\n    expect(\n      concatSig(\n        Buffer.from('1', 'hex'),\n        Buffer.from('1', 'hex'),\n        Buffer.from('1', 'hex'),\n      ),\n    ).toMatchInlineSnapshot(\n      `\"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n    );\n  });\n\n  it('should concatenate an all-zero extended ECDSA signature', function () {\n    expect(\n      concatSig(\n        Buffer.from('0', 'hex'),\n        Buffer.from('0', 'hex'),\n        Buffer.from('0', 'hex'),\n      ),\n    ).toMatchInlineSnapshot(\n      `\"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n    );\n  });\n\n  it('should return a hex-prefixed string', function () {\n    const signature = concatSig(\n      Buffer.from('1', 'hex'),\n      Buffer.from('1', 'hex'),\n      Buffer.from('1', 'hex'),\n    );\n\n    expect(typeof signature).toBe('string');\n    expect(signature.slice(0, 2)).toBe('0x');\n  });\n\n  it('should encode an impossibly large extended ECDSA signature', function () {\n    const largeNumber = Number.MAX_SAFE_INTEGER.toString(16);\n    expect(\n      concatSig(\n        Buffer.from(largeNumber, 'hex'),\n        Buffer.from(largeNumber, 'hex'),\n        Buffer.from(largeNumber, 'hex'),\n      ),\n    ).toMatchInlineSnapshot(\n      `\"0x000000000000000000000000000000000000000000000000001fffffffffffff000000000000000000000000000000000000000000000000001fffffffffffff1fffffffffffff\"`,\n    );\n  });\n\n  it('should throw if a portion of the signature is larger than the maximum safe integer', function () {\n    const largeNumber = '20000000000000'; // This is Number.MAX_SAFE_INTEGER + 1, in hex\n    expect(() =>\n      concatSig(\n        Buffer.from(largeNumber, 'hex'),\n        Buffer.from(largeNumber, 'hex'),\n        Buffer.from(largeNumber, 'hex'),\n      ),\n    ).toThrow('Number exceeds 53 bits');\n  });\n});\n\ndescribe('normalize', function () {\n  it('should normalize an address to lower case', function () {\n    const initial = '0xA06599BD35921CfB5B71B4BE3869740385b0B306';\n    const result = normalize(initial);\n    expect(result).toBe(initial.toLowerCase());\n  });\n\n  it('should normalize address without a 0x prefix', function () {\n    const initial = 'A06599BD35921CfB5B71B4BE3869740385b0B306';\n    const result = normalize(initial);\n    expect(result).toBe(`0x${initial.toLowerCase()}`);\n  });\n\n  it('should normalize 0 to a byte-pair hex string', function () {\n    const initial = 0;\n    const result = normalize(initial);\n    expect(result).toBe('0x00');\n  });\n\n  it('should normalize an integer to a byte-pair hex string', function () {\n    const initial = 1;\n    const result = normalize(initial);\n    expect(result).toBe('0x01');\n  });\n\n  // TODO: Add validation to disallow negative integers.\n  it('should normalize a negative integer to 0x', function () {\n    const initial = -1;\n    const result = normalize(initial);\n    expect(result).toBe('0x');\n  });\n\n  it('should normalize an empty string to 0x', function () {\n    const initial = '';\n    const result = normalize(initial);\n    expect(result).toBe('0x');\n  });\n\n  // TODO: Add validation to disallow null.\n  it('should return undefined if given null', function () {\n    const initial = null;\n    expect(normalize(initial as any)).toBeUndefined();\n  });\n\n  // TODO: Add validation to disallow undefined.\n  it('should return undefined if given undefined', function () {\n    const initial = undefined;\n    expect(normalize(initial as any)).toBeUndefined();\n  });\n\n  it('should throw if given an object', function () {\n    const initial = {};\n    expect(() => normalize(initial as any)).toThrow(\n      'eth-sig-util.normalize() requires hex string or integer input. received object:',\n    );\n  });\n\n  it('should throw if given a boolean', function () {\n    const initial = true;\n    expect(() => normalize(initial as any)).toThrow(\n      'eth-sig-util.normalize() requires hex string or integer input. received boolean: true',\n    );\n  });\n\n  it('should throw if given a bigint', function () {\n    const initial = BigInt(Number.MAX_SAFE_INTEGER);\n    expect(() => normalize(initial as any)).toThrow(\n      'eth-sig-util.normalize() requires hex string or integer input. received bigint: 9007199254740991',\n    );\n  });\n\n  it('should throw if given a symbol', function () {\n    const initial = Symbol('test');\n    expect(() => normalize(initial as any)).toThrow(\n      'Cannot convert a Symbol value to a string',\n    );\n  });\n});\n"]}