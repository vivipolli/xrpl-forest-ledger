import { Messages } from '@trezor/transport';
import type { ReadWriteError } from '@trezor/transport/lib/transports/abstract';
import { DEVICE } from '../events';
import type { Device, DeviceEvents } from './Device';
type PromptEvents = typeof DEVICE.PIN | typeof DEVICE.PASSPHRASE | typeof DEVICE.WORD;
type DeviceEventCallback<K extends PromptEvents> = DeviceEvents[K]['callback'];
type PromptReturnType<E extends PromptEvents> = {
    success: true;
    payload: NonNullable<Parameters<DeviceEventCallback<E>>[0]>;
} | {
    success: false;
    isTransportError: false;
    error: string;
    message: string;
} | {
    success: false;
    isTransportError: true;
    error: ReadWriteError;
};
export type PromptCallback<T> = (response: T | null, error?: string) => void;
export declare const cancelPrompt: (device: Device, expectResponse?: boolean) => Promise<{
    success: false;
    error: "session not found";
}> | import("@trezor/transport/lib/types").AsyncResultWithTypedError<import("@trezor/protobuf").MessageFromTrezor, ReadWriteError> | import("@trezor/transport/lib/types").AsyncResultWithTypedError<undefined, ReadWriteError>;
export declare const promptPassphrase: (device: Device) => Promise<PromptReturnType<"passphrase">>;
export declare const promptPin: (device: Device, type?: Messages.PinMatrixRequestType) => Promise<PromptReturnType<"pin">>;
export declare const promptWord: (device: Device, type: Messages.WordRequestType) => Promise<PromptReturnType<"word">>;
export {};
//# sourceMappingURL=prompts.d.ts.map