'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var base = require('@web3auth/base');
var mipd = require('mipd');
var injectedEvmAdapter = require('./injectedEvmAdapter.js');

const getInjectedAdapters = params => {
  const {
    options
  } = params;
  const {
    clientId,
    chainConfig,
    sessionTime,
    web3AuthNetwork,
    useCoreKitKey
  } = options;
  if (!Object.values(base.CHAIN_NAMESPACES).includes(chainConfig.chainNamespace)) throw base.WalletInitializationError.invalidParams(`Invalid chainNamespace: ${chainConfig.chainNamespace}`);
  const finalChainConfig = _objectSpread(_objectSpread({}, base.getChainConfig(chainConfig.chainNamespace, chainConfig === null || chainConfig === void 0 ? void 0 : chainConfig.chainId, clientId)), chainConfig || {});
  // EIP-6963: multiple injected provider discovery
  const mipd$1 = mipd.createStore();
  // We assume that all extensions have emitted by here.
  // TODO: Ideally, we must use reactive listening. We will do that with v9
  const injectedProviders = mipd$1.getProviders().map(providerDetail => {
    return new injectedEvmAdapter.InjectedEvmAdapter({
      name: base.normalizeWalletName(providerDetail.info.name),
      provider: providerDetail.provider,
      chainConfig: finalChainConfig,
      clientId,
      sessionTime,
      web3AuthNetwork,
      useCoreKitKey
    });
  });
  return injectedProviders;
};

exports.getInjectedAdapters = getInjectedAdapters;
