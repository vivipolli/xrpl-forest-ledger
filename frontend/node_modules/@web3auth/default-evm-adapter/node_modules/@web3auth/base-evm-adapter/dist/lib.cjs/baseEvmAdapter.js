'use strict';

var baseControllers = require('@toruslabs/base-controllers');
var base = require('@web3auth/base');

class BaseEvmAdapter extends base.BaseAdapter {
  async init(_) {
    if (!this.chainConfig) this.chainConfig = base.getChainConfig(base.CHAIN_NAMESPACES.EIP155, 1, this.clientId);
  }
  async authenticateUser() {
    if (!this.provider || this.status !== base.ADAPTER_STATUS.CONNECTED) throw base.WalletLoginError.notConnectedError();
    const {
      chainNamespace,
      chainId
    } = this.chainConfig;
    const accounts = await this.provider.request({
      method: "eth_accounts"
    });
    if (accounts && accounts.length > 0) {
      const existingToken = base.getSavedToken(accounts[0], this.name);
      if (existingToken) {
        const isExpired = base.checkIfTokenIsExpired(existingToken);
        if (!isExpired) {
          return {
            idToken: existingToken
          };
        }
      }
      const payload = {
        domain: window.location.origin,
        uri: window.location.href,
        address: accounts[0],
        chainId: parseInt(chainId, 16),
        version: "1",
        nonce: Math.random().toString(36).slice(2),
        issuedAt: new Date().toISOString()
      };
      const challenge = await baseControllers.signChallenge(payload, chainNamespace);
      const hexChallenge = `0x${Buffer.from(challenge, "utf8").toString("hex")}`;
      const signedMessage = await this.provider.request({
        method: "personal_sign",
        params: [hexChallenge, accounts[0]]
      });
      const idToken = await baseControllers.verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime, this.clientId, this.web3AuthNetwork);
      base.saveToken(accounts[0], this.name, idToken);
      return {
        idToken
      };
    }
    throw base.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
  }
  async disconnectSession() {
    super.checkDisconnectionRequirements();
    const accounts = await this.provider.request({
      method: "eth_accounts"
    });
    if (accounts && accounts.length > 0) {
      base.clearToken(accounts[0], this.name);
    }
  }
  async disconnect() {
    this.rehydrated = false;
    this.emit(base.ADAPTER_EVENTS.DISCONNECTED);
  }
}

exports.BaseEvmAdapter = BaseEvmAdapter;
