/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 845:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ux: () => (/* reexport */ EIP1559APIEndpoint),
  Bl: () => (/* reexport */ EthereumPrivateKeyProvider),
  ve: () => (/* reexport */ GAS_ESTIMATE_TYPES),
  Og: () => (/* reexport */ LegacyGasAPIEndpoint),
  aU: () => (/* reexport */ SignTypedDataVersion),
  yH: () => (/* reexport */ TRANSACTION_ENVELOPE_TYPES),
  t2: () => (/* reexport */ TRANSACTION_TYPES),
  NX: () => (/* reexport */ TransactionFormatter),
  r8: () => (/* reexport */ fetchEip1159GasEstimates),
  hY: () => (/* reexport */ fetchLegacyGasPriceEstimates),
  b6: () => (/* reexport */ getProviderHandlers),
  vo: () => (/* reexport */ normalizeGWEIDecimalNumbers),
  jl: () => (/* reexport */ validateAddress),
  lG: () => (/* reexport */ validateTypedSignMessageDataV4)
});

;// external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// external "@ethereumjs/util"
const util_namespaceObject = require("@ethereumjs/util");
// EXTERNAL MODULE: external "@web3auth/auth"
var auth_ = __webpack_require__(894);
;// external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// external "@web3auth/base-provider"
const base_provider_namespaceObject = require("@web3auth/base-provider");
// EXTERNAL MODULE: ./src/rpc/ethRpcMiddlewares.ts
var ethRpcMiddlewares = __webpack_require__(673);
// EXTERNAL MODULE: ./src/rpc/jrpcClient.ts
var jrpcClient = __webpack_require__(94);
// EXTERNAL MODULE: external "@babel/runtime/helpers/objectSpread2"
var objectSpread2_ = __webpack_require__(846);
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_);
// EXTERNAL MODULE: external "@toruslabs/base-controllers"
var base_controllers_ = __webpack_require__(885);
;// external "@toruslabs/eccrypto"
const eccrypto_namespaceObject = require("@toruslabs/eccrypto");
// EXTERNAL MODULE: external "ethers"
var external_ethers_ = __webpack_require__(999);
;// external "viem"
const external_viem_namespaceObject = require("viem");
;// external "@toruslabs/http-helpers"
const http_helpers_namespaceObject = require("@toruslabs/http-helpers");
;// external "bignumber.js"
const external_bignumber_js_namespaceObject = require("bignumber.js");
;// ./src/providers/converter.ts


// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new external_bignumber_js_namespaceObject.BigNumber("1e18");
const BIG_NUMBER_GWEI_MULTIPLIER = new external_bignumber_js_namespaceObject.BigNumber("1e9");
const BIG_NUMBER_ETH_MULTIPLIER = new external_bignumber_js_namespaceObject.BigNumber("1");

// Setter Maps
const toBigNumber = {
  hex: n => typeof n === "string" ? new external_bignumber_js_namespaceObject.BigNumber((0,util_namespaceObject.stripHexPrefix)(n), 16) : new external_bignumber_js_namespaceObject.BigNumber(n, 16),
  dec: n => new external_bignumber_js_namespaceObject.BigNumber(n, 10)
};
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, external_bignumber_js_namespaceObject.BigNumber.ROUND_HALF_UP),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, external_bignumber_js_namespaceObject.BigNumber.ROUND_HALF_UP),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, external_bignumber_js_namespaceObject.BigNumber.ROUND_HALF_UP)
};
const baseChange = {
  hex: n => n.toString(16),
  dec: n => new external_bignumber_js_namespaceObject.BigNumber(n).toString(10)
};
const converter = params => {
  const {
    value,
    fromNumericBase,
    fromDenomination,
    toNumericBase,
    toDenomination,
    numberOfDecimals
  } = params;
  let convertedValue = toBigNumber[fromNumericBase](value);
  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }
  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }
  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, external_bignumber_js_namespaceObject.BigNumber.ROUND_HALF_DOWN);
  }
  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};
const conversionUtil = (value, {
  fromNumericBase = "hex",
  toNumericBase,
  fromDenomination,
  toDenomination,
  numberOfDecimals
}) => {
  return converter({
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    value: value || "0"
  });
};
function decGWEIToHexWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
}
function hexWEIToDecGWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
}

;// ./src/providers/privateKeyProviders/TransactionFormatter/utils.ts




function normalizeGWEIDecimalNumbers(n) {
  const numberAsWEIHex = decGWEIToHexWEI(n);
  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex).toString();
  return numberAsGWEI;
}
async function fetchEip1159GasEstimates(url) {
  const estimates = await (0,http_helpers_namespaceObject.get)(url);
  const normalizedEstimates = objectSpread2_default()(objectSpread2_default()({}, estimates), {}, {
    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
    low: objectSpread2_default()(objectSpread2_default()({}, estimates.low), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)
    }),
    medium: objectSpread2_default()(objectSpread2_default()({}, estimates.medium), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)
    }),
    high: objectSpread2_default()(objectSpread2_default()({}, estimates.high), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)
    })
  });
  return normalizedEstimates;
}

/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 */
async function fetchLegacyGasPriceEstimates(url) {
  const result = await (0,http_helpers_namespaceObject.get)(url, {
    referrer: url,
    referrerPolicy: "no-referrer-when-downgrade",
    method: "GET",
    mode: "cors"
  });
  return {
    low: result.SafeGasPrice,
    medium: result.ProposeGasPrice,
    high: result.FastGasPrice
  };
}
function validateAddress(address, propertyName) {
  if (!address || typeof address !== "string" || !(0,util_namespaceObject.isValidAddress)(address)) {
    throw new Error(`Invalid "${propertyName}" address: ${address} must be a valid string.`);
  }
}
async function validateTypedSignMessageDataV4(messageData, currentChainId) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || Array.isArray(messageData.data) || typeof messageData.data !== "object" && typeof messageData.data !== "string") {
    throw new Error(`Invalid message "data": Must be a valid string or object.`);
  }
  let data;
  if (typeof messageData.data === "object") {
    data = messageData.data;
  } else {
    try {
      data = JSON.parse(messageData.data);
    } catch (e) {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  }
  if (!currentChainId) {
    throw new Error("Current chainId cannot be null or undefined.");
  }
  let {
    chainId
  } = data.domain;
  if (chainId) {
    if (typeof chainId === "string") {
      chainId = parseInt(chainId, chainId.startsWith("0x") ? 16 : 10);
    }
    const activeChainId = parseInt(currentChainId, 16);
    if (Number.isNaN(activeChainId)) {
      throw new Error(`Cannot sign messages for chainId "${chainId}", because Web3Auth is switching networks.`);
    }
    if (chainId !== activeChainId) {
      throw new Error(`Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
    }
  }
}
;// ./src/providers/privateKeyProviders/ethPrivatekeyUtils.ts









async function signTx(txParams, privKey, txFormatter) {
  const finalTxParams = await txFormatter.formatTransaction(txParams);
  const {
    Transaction
  } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 999, 23));
  const ethTx = Transaction.from(objectSpread2_default()(objectSpread2_default()({}, finalTxParams), {}, {
    from: undefined // from is already calculated inside Transaction.from and is not allowed to be passed in
  }));
  const signKey = new external_ethers_.SigningKey((0,util_namespaceObject.addHexPrefix)(privKey));
  ethTx.signature = signKey.sign(ethTx.unsignedHash);
  return ethTx.serialized;
}
function getProviderHandlers({
  txFormatter,
  privKey,
  keyExportEnabled,
  getProviderEngineProxy
}) {
  return {
    getAccounts: async _ => [`0x${Buffer.from((0,util_namespaceObject.privateToAddress)(Buffer.from(privKey, "hex"))).toString("hex")}`],
    getPublicKey: async _ => {
      const publicKey = (0,eccrypto_namespaceObject.getPublicCompressed)(Buffer.from((0,util_namespaceObject.stripHexPrefix)(privKey), "hex"));
      return `0x${Buffer.from(publicKey).toString("hex")}`;
    },
    getPrivateKey: async _ => {
      if (!keyExportEnabled) throw auth_.providerErrors.custom({
        message: "Private key export is disabled",
        code: 4902
      });
      return privKey;
    },
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth_.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      if (txParams.input && !txParams.data) txParams.data = (0,util_namespaceObject.addHexPrefix)(txParams.input);
      const serializedTx = await signTx(txParams, privKey, txFormatter);
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: [serializedTx]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth_.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      if (txParams.input && !txParams.data) txParams.data = (0,util_namespaceObject.addHexPrefix)(txParams.input);
      const serializedTx = await signTx(txParams, privKey, txFormatter);
      return serializedTx;
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = (0,base_controllers_.signMessage)(privKey, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const ethersKey = new external_ethers_.SigningKey(privKeyBuffer);
      const {
        data
      } = msgParams;
      // we need to check if the data is hex or not
      // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
      // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
      const message = (0,util_namespaceObject.isHexString)(data) ? Buffer.from((0,util_namespaceObject.stripHexPrefix)(data), "hex") : Buffer.from(data);
      const signature = ethersKey.sign((0,external_ethers_.hashMessage)(message));
      return signature.serialized;
    },
    processTypedMessageV4: async (msgParams, _) => {
      base_namespaceObject.log.debug("processTypedMessageV4", msgParams);
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth_.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const chainId = await providerEngineProxy.request({
        method: "eth_chainId"
      });
      await validateTypedSignMessageDataV4(msgParams, chainId);
      const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
      const ethersPrivateKey = new external_ethers_.SigningKey(privKeyBuffer);
      (0,external_viem_namespaceObject.validateTypedData)(data);
      const signature = ethersPrivateKey.sign((0,external_viem_namespaceObject.hashTypedData)(data)).serialized;
      return signature;
    }
  };
}
;// external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// ./src/providers/utils.ts



function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new external_bignumber_js_namespaceObject.BigNumber(a, 10).lt(b, 10);
}
function bnToHex(inputBn) {
  return (0,util_namespaceObject.addHexPrefix)(inputBn.toString(16));
}
function hexToBn(inputHex) {
  if (external_bn_js_default().isBN(inputHex)) return inputHex;
  return new (external_bn_js_default())((0,util_namespaceObject.stripHexPrefix)(inputHex), 16);
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  const numberBN = new (external_bn_js_default())(numerator);
  const denomBN = new (external_bn_js_default())(denominator);
  return targetBN.mul(numberBN).div(denomBN);
}
;// ./src/providers/privateKeyProviders/TransactionFormatter/constants.ts
const LegacyGasAPIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices";
const EIP1559APIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees";
const TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: "0x0",
  ACCESS_LIST: "0x1",
  FEE_MARKET: "0x2"
};
const TRANSACTION_TYPES = {
  SENT_ETHER: "sentEther",
  CONTRACT_INTERACTION: "contractInteraction",
  DEPLOY_CONTRACT: "contractDeployment",
  STANDARD_TRANSACTION: "transaction"
};
const GAS_ESTIMATE_TYPES = {
  FEE_MARKET: "fee-market",
  LEGACY: "legacy",
  ETH_GASPRICE: "eth_gasPrice",
  NONE: "none"
};
;// ./src/providers/privateKeyProviders/TransactionFormatter/formatter.ts









class TransactionFormatter {
  constructor({
    getProviderEngineProxy
  }) {
    // https://0x.org/docs/introduction/0x-cheat-sheet#swap-api-endpoints
    defineProperty_default()(this, "API_SUPPORTED_CHAINIDS", new Set(["0x1", "0x5", "0x13881", "0xa4b1", "0xa86a", "0x2105", "0x38", "0xfa", "0xa", "0x89"]));
    defineProperty_default()(this, "chainConfig", null);
    defineProperty_default()(this, "getProviderEngineProxy", void 0);
    defineProperty_default()(this, "isEIP1559Compatible", false);
    this.getProviderEngineProxy = getProviderEngineProxy;
  }
  get providerProxy() {
    return this.getProviderEngineProxy();
  }
  async init() {
    this.chainConfig = await this.providerProxy.request({
      method: "eth_provider_config"
    });
    this.isEIP1559Compatible = await this.getEIP1559Compatibility();
  }
  async formatTransaction(txParams) {
    if (!this.chainConfig) throw new Error("Chain config not initialized");
    const clonedTxParams = objectSpread2_default()({}, txParams);
    if (clonedTxParams.nonce === undefined) clonedTxParams.nonce = await this.providerProxy.request({
      method: "eth_getTransactionCount",
      params: [txParams.from, "latest"]
    });
    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {
      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;
      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas;
      // if user provides gas Limit, we should use it instead
      // if gas is not provided explicitly, estimate it.
      if (!clonedTxParams.gasLimit) {
        if (!clonedTxParams.gas) {
          const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);
          if (defaultGasLimit) {
            clonedTxParams.gasLimit = defaultGasLimit;
          }
        } else {
          clonedTxParams.gasLimit = (0,util_namespaceObject.addHexPrefix)(clonedTxParams.gas);
        }
      }
      return clonedTxParams;
    }
    if (!clonedTxParams.gasLimit) {
      if (!clonedTxParams.gas) {
        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);
        if (defaultGasLimit) {
          clonedTxParams.gasLimit = defaultGasLimit;
        }
      } else {
        clonedTxParams.gasLimit = (0,util_namespaceObject.addHexPrefix)(clonedTxParams.gas);
      }
    }
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this.getDefaultGasFees(clonedTxParams);
    if (this.isEIP1559Compatible) {
      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;
        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? (0,util_namespaceObject.stripHexPrefix)(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === "string" ? (0,util_namespaceObject.stripHexPrefix)(clonedTxParams.gasPrice) : clonedTxParams.gasPrice.toString()) ? (0,util_namespaceObject.addHexPrefix)(defaultMaxPriorityFeePerGas) : (0,util_namespaceObject.addHexPrefix)(clonedTxParams.gasPrice.toString());
      } else {
        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          clonedTxParams.maxFeePerGas = (0,util_namespaceObject.addHexPrefix)(defaultMaxFeePerGas);
        }
        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          clonedTxParams.maxPriorityFeePerGas = (0,util_namespaceObject.addHexPrefix)(defaultMaxPriorityFeePerGas);
        }
        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          clonedTxParams.maxFeePerGas = (0,util_namespaceObject.addHexPrefix)(defaultGasPrice);
        }
        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available  then we set maxPriorityFeePerGas to
          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;
        }
      }

      // We remove the gasPrice param entirely when on an eip1559 compatible network

      delete clonedTxParams.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network

      delete clonedTxParams.maxPriorityFeePerGas;
      delete clonedTxParams.maxFeePerGas;
    }

    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.
    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {
      clonedTxParams.gasPrice = defaultGasPrice;
    }
    clonedTxParams.type = Number.parseInt(this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY, 16);
    clonedTxParams.chainId = this.chainConfig.chainId;
    return clonedTxParams;
  }
  async fetchEthGasPriceEstimate() {
    const gasPrice = await this.providerProxy.request({
      method: "eth_gasPrice",
      params: []
    });
    return {
      gasPrice: hexWEIToDecGWEI(gasPrice).toString()
    };
  }
  async fetchGasEstimatesViaEthFeeHistory() {
    const noOfBlocks = 10;
    const newestBlock = "latest";
    // get the 10, 50 and 95th percentile of the tip fees from the last 10 blocks
    const percentileValues = [10, 50, 95];
    const feeHistory = await this.providerProxy.request({
      method: "eth_feeHistory",
      params: [noOfBlocks, newestBlock, percentileValues]
    });

    // this is in hex wei
    const finalBaseFeePerGas = feeHistory.baseFeePerGas[feeHistory.baseFeePerGas.length - 1];
    // this is in hex wei
    const priorityFeeCalcs = feeHistory.reward.reduce((acc, curr) => {
      return {
        slow: acc.slow.plus(new external_bignumber_js_namespaceObject.BigNumber(curr[0], 16)),
        average: acc.average.plus(new external_bignumber_js_namespaceObject.BigNumber(curr[1], 16)),
        fast: acc.fast.plus(new external_bignumber_js_namespaceObject.BigNumber(curr[2], 16))
      };
    }, {
      slow: new external_bignumber_js_namespaceObject.BigNumber(0),
      average: new external_bignumber_js_namespaceObject.BigNumber(0),
      fast: new external_bignumber_js_namespaceObject.BigNumber(0)
    });
    return {
      estimatedBaseFee: hexWEIToDecGWEI(finalBaseFeePerGas).toString(),
      high: {
        maxWaitTimeEstimate: 30000,
        minWaitTimeEstimate: 15000,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.plus(finalBaseFeePerGas).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.toString(16)).toString()
      },
      medium: {
        maxWaitTimeEstimate: 45000,
        minWaitTimeEstimate: 15000,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.plus(finalBaseFeePerGas).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.toString(16)).toString()
      },
      low: {
        maxWaitTimeEstimate: 60000,
        minWaitTimeEstimate: 15000,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.plus(finalBaseFeePerGas).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.toString(16)).toString()
      }
    };
  }
  async getEIP1559Compatibility() {
    const latestBlock = await this.providerProxy.request({
      method: "eth_getBlockByNumber",
      params: ["latest", false]
    });
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    return !!supportsEIP1559;
  }
  async fetchGasFeeEstimateData() {
    if (!this.chainConfig) throw new Error("Chain config not initialized");
    const isLegacyGasAPICompatible = this.chainConfig.chainId === "0x1";
    const chainId = Number.parseInt(this.chainConfig.chainId, 16);
    let gasData;
    try {
      if (this.isEIP1559Compatible) {
        let estimates;
        try {
          if (this.API_SUPPORTED_CHAINIDS.has(this.chainConfig.chainId)) {
            estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace("<chain_id>", `${chainId}`));
          } else {
            throw new Error("Chain id not supported by api");
          }
        } catch (error) {
          estimates = await this.fetchGasEstimatesViaEthFeeHistory();
        }
        gasData = {
          gasFeeEstimates: estimates,
          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
        };
      } else if (isLegacyGasAPICompatible) {
        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace("<chain_id>", `${chainId}`));
        gasData = {
          gasFeeEstimates: estimates,
          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
        };
      } else {
        throw new Error("Main gas fee/price estimation failed. Use fallback");
      }
    } catch (e) {
      try {
        const estimates = await this.fetchEthGasPriceEstimate();
        gasData = {
          gasFeeEstimates: estimates,
          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
        };
      } catch (error) {
        throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
      }
    }
    return gasData;
  }
  async getDefaultGasFees(txParams) {
    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {
      return {};
    }
    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this.fetchGasFeeEstimateData();
      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;
        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            maxFeePerGas: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(suggestedMaxFeePerGas)),
            maxPriorityFeePerGas: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))
          };
        }
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(gasFeeEstimates.medium))
        };
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(gasFeeEstimates.gasPrice))
        };
      }
    } catch (error) {
      base_namespaceObject.log.error(error);
    }
    const {
      gasPrice
    } = await this.fetchEthGasPriceEstimate();
    return {
      gasPrice: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(gasPrice))
    };
  }
  async estimateTxGas(txMeta) {
    const txParams = objectSpread2_default()({}, txMeta);

    // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;
    const gas = await this.providerProxy.request({
      method: "eth_estimateGas",
      params: [txParams]
    });
    return gas;
  }
  async analyzeGasUsage(txMeta) {
    const block = await this.providerProxy.request({
      method: "eth_getBlockByNumber",
      params: ["latest", false]
    });
    // fallback to block gasLimit
    const blockGasLimitBN = hexToBn(block.gasLimit);
    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
    let estimatedGasHex = bnToHex(saferGasLimitBN);
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      base_namespaceObject.log.warn(error);
    }
    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex
    };
  }
  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = hexToBn(initialGasLimitHex);
    const blockGasLimitBn = hexToBn(blockGasLimitHex);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);

    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn);
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn);
    // otherwise use blockGasLimit
    return bnToHex(upperGasLimitBn);
  }
  async determineTransactionCategory(txParameters) {
    const {
      data,
      to
    } = txParameters;
    let code = "";
    let txCategory;
    if (data && !to) {
      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;
    } else {
      try {
        code = await this.providerProxy.request({
          method: "eth_getCode",
          params: [to, "latest"]
        });
      } catch (error) {
        base_namespaceObject.log.warn(error);
      }
      const codeIsEmpty = !code || code === "0x" || code === "0x0";
      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;
    }
    return {
      transactionCategory: txCategory,
      code
    };
  }
  async getDefaultGasLimit(txParams) {
    const {
      transactionCategory
    } = await this.determineTransactionCategory(objectSpread2_default()({}, txParams));
    if (txParams.gas) {
      return (0,util_namespaceObject.addHexPrefix)(txParams.gas);
    }
    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {
      // if there's data in the params, but there's no contract code, it's not a valid transaction
      if (txParams.data) {
        throw Error("TxGasUtil - Trying to call a function on a non-contract address");
      }
      const TWENTY_ONE_THOUSAND = 21000;

      // This is a standard ether simple send, gas requirement is exactly 21k
      return (0,util_namespaceObject.addHexPrefix)(TWENTY_ONE_THOUSAND.toString(16));
    }
    const {
      blockGasLimit,
      estimatedGasHex
    } = await this.analyzeGasUsage(txParams);

    // add additional gas buffer to our estimation for safety
    const gasLimit = this.addGasBuffer((0,util_namespaceObject.addHexPrefix)(estimatedGasHex), blockGasLimit);
    return gasLimit;
  }
}
;// ./src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts

var _EthereumPrivateKeyProvider;








class EthereumPrivateKeyProvider extends base_provider_namespaceObject.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "PROVIDER_CHAIN_NAMESPACE", base_namespaceObject.CHAIN_NAMESPACES.EIP155);
  }
  async enable() {
    if (!this.state.privateKey) throw auth_.providerErrors.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider(privKey) {
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base_namespaceObject.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const txFormatter = new TransactionFormatter({
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const providerHandlers = getProviderHandlers({
      txFormatter,
      privKey,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this),
      keyExportEnabled: this.config.keyExportEnabled
    });
    const ethMiddleware = (0,ethRpcMiddlewares/* createEthMiddleware */.ao)(providerHandlers);
    const chainSwitchMiddleware = this.getChainSwitchMiddleware();
    const engine = new auth_.JRPCEngine();
    // Not a partial anymore because of checks in ctor
    const {
      networkMiddleware
    } = (0,jrpcClient/* createJsonRpcClient */.vx)(this.config.chainConfig);
    engine.push(ethMiddleware);
    engine.push(chainSwitchMiddleware);
    engine.push(this.getAccountMiddleware());
    engine.push(networkMiddleware);
    const provider = (0,auth_.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    await txFormatter.init();
    await this.lookupNetwork();
  }
  async updateAccount(params) {
    if (!this._providerEngineProxy) throw auth_.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const existingKey = await this._providerEngineProxy.request({
      method: "eth_private_key"
    });
    if (existingKey !== params.privateKey) {
      await this.setupProvider(params.privateKey);
      const accounts = await this._providerEngineProxy.request({
        method: "eth_accounts"
      });
      this.emit("accountsChanged", accounts);
    }
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth_.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const privKey = await this._providerEngineProxy.request({
      method: "eth_private_key"
    });
    await this.setupProvider(privKey);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw auth_.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw auth_.rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const network = await this._providerEngineProxy.request({
      method: "net_version",
      params: []
    });
    const finalNetwork = (0,util_namespaceObject.isHexString)(network) ? parseInt(network, 16) : parseInt(network, 10);
    if (parseInt(chainId, 16) !== finalNetwork) throw auth_.providerErrors.chainDisconnected(`Invalid network, net_version is: ${network}`);
    if (this.state.chainId !== chainId) {
      this.emit("chainChanged", chainId);
      this.emit("connect", {
        chainId
      });
    }
    this.update({
      chainId
    });
    return network;
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChain: async params => {
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency,
          iconUrls
        } = params;
        this.addChain({
          chainNamespace: base_namespaceObject.CHAIN_NAMESPACES.EIP155,
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorerUrl: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || "",
          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 18,
          logo: (iconUrls === null || iconUrls === void 0 ? void 0 : iconUrls[0]) || "https://images.toruswallet.io/eth.svg"
        });
      },
      switchChain: async params => {
        const {
          chainId
        } = params;
        await this.switchChain({
          chainId
        });
      }
    };
    const chainSwitchMiddleware = (0,ethRpcMiddlewares/* createChainSwitchMiddleware */.Es)(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
  getAccountMiddleware() {
    const accountHandlers = {
      updatePrivatekey: async params => {
        const {
          privateKey
        } = params;
        await this.updateAccount({
          privateKey
        });
      }
    };
    return (0,ethRpcMiddlewares/* createAccountMiddleware */.gn)(accountHandlers);
  }
}
_EthereumPrivateKeyProvider = EthereumPrivateKeyProvider;
defineProperty_default()(EthereumPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _EthereumPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});
;// ./src/providers/privateKeyProviders/TransactionFormatter/interfaces.ts
let SignTypedDataVersion = /*#__PURE__*/function (SignTypedDataVersion) {
  SignTypedDataVersion["V1"] = "V1";
  SignTypedDataVersion["V3"] = "V3";
  SignTypedDataVersion["V4"] = "V4";
  return SignTypedDataVersion;
}({});
;// ./src/providers/privateKeyProviders/TransactionFormatter/index.ts




;// ./src/providers/privateKeyProviders/index.ts



;// ./src/providers/index.ts


/***/ }),

/***/ 673:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Es: () => (/* binding */ createChainSwitchMiddleware),
/* harmony export */   ao: () => (/* binding */ createEthMiddleware),
/* harmony export */   gn: () => (/* binding */ createAccountMiddleware)
/* harmony export */ });
/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(894);
/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _walletMidddleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(953);


function createEthMiddleware(providerHandlers) {
  const {
    getAccounts,
    getPrivateKey,
    getPublicKey,
    processTransaction,
    processSignTransaction,
    processEthSignMessage,
    processTypedMessageV4,
    processPersonalMessage
  } = providerHandlers;
  const ethMiddleware = (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.mergeMiddleware)([(0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.createScaffoldMiddleware)({
    eth_syncing: false
  }), (0,_walletMidddleware__WEBPACK_IMPORTED_MODULE_1__/* .createWalletMiddleware */ .s)({
    getAccounts,
    getPrivateKey,
    getPublicKey,
    processTransaction,
    processEthSignMessage,
    processSignTransaction,
    processTypedMessageV4,
    processPersonalMessage
  })]);
  return ethMiddleware;
}
function createChainSwitchMiddleware({
  addChain,
  switchChain
}) {
  async function addNewChain(req, res) {
    var _req$params;
    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;
    if (!chainParams) throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.invalidParams("Missing chain params");
    if (!chainParams.chainId) throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.invalidParams("Missing chainId in chainParams");
    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.invalidParams("Missing rpcUrls in chainParams");
    if (!chainParams.nativeCurrency) throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.invalidParams("Missing nativeCurrency in chainParams");
    res.result = await addChain(chainParams);
  }
  async function updateChain(req, res) {
    var _req$params2;
    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;
    if (!chainParams) throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.invalidParams("Missing chainId");
    res.result = await switchChain(chainParams);
  }
  return (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.createScaffoldMiddleware)({
    wallet_addEthereumChain: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.createAsyncMiddleware)(addNewChain),
    wallet_switchEthereumChain: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.createAsyncMiddleware)(updateChain)
  });
}

// #region account middlewares
function createAccountMiddleware({
  updatePrivatekey
}) {
  async function updateAccount(req, res) {
    var _req$params3;
    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;
    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.invalidParams("Missing privateKey");
    res.result = await updatePrivatekey(accountParams);
  }
  return (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.createScaffoldMiddleware)({
    wallet_updateAccount: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.createAsyncMiddleware)(updateAccount)
  });
}

// #endregion account middlewares

/***/ }),

/***/ 6:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAccountMiddleware: () => (/* reexport safe */ _ethRpcMiddlewares__WEBPACK_IMPORTED_MODULE_0__.gn),
/* harmony export */   createChainIdMiddleware: () => (/* reexport safe */ _jrpcClient__WEBPACK_IMPORTED_MODULE_2__.Rn),
/* harmony export */   createChainSwitchMiddleware: () => (/* reexport safe */ _ethRpcMiddlewares__WEBPACK_IMPORTED_MODULE_0__.Es),
/* harmony export */   createEthMiddleware: () => (/* reexport safe */ _ethRpcMiddlewares__WEBPACK_IMPORTED_MODULE_0__.ao),
/* harmony export */   createJsonRpcClient: () => (/* reexport safe */ _jrpcClient__WEBPACK_IMPORTED_MODULE_2__.vx),
/* harmony export */   createProviderConfigMiddleware: () => (/* reexport safe */ _jrpcClient__WEBPACK_IMPORTED_MODULE_2__.Eu),
/* harmony export */   createWalletMiddleware: () => (/* reexport safe */ _walletMidddleware__WEBPACK_IMPORTED_MODULE_3__.s)
/* harmony export */ });
/* harmony import */ var _ethRpcMiddlewares__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(673);
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(604);
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_interfaces__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _interfaces__WEBPACK_IMPORTED_MODULE_1__) if(["default","createAccountMiddleware","createChainSwitchMiddleware","createEthMiddleware"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _interfaces__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _jrpcClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94);
/* harmony import */ var _walletMidddleware__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(953);





/***/ }),

/***/ 604:
/***/ (() => {



/***/ }),

/***/ 94:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Eu: () => (/* binding */ createProviderConfigMiddleware),
/* harmony export */   Rn: () => (/* binding */ createChainIdMiddleware),
/* harmony export */   vx: () => (/* binding */ createJsonRpcClient)
/* harmony export */ });
/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(885);
/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(894);
/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__);


function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = (0,_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_0__.createFetchMiddleware)({
    rpcTarget
  });
  const networkMiddleware = (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.mergeMiddleware)([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}

/***/ }),

/***/ 953:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ createWalletMiddleware)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(846);
/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(894);
/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__);


function createWalletMiddleware({
  getAccounts,
  getPrivateKey,
  getPublicKey,
  processEthSignMessage,
  processPersonalMessage,
  processTransaction,
  processSignTransaction,
  processTypedMessageV4
}) {
  if (!getAccounts) {
    throw new Error("opts.getAccounts is required");
  }

  //
  // utility
  //

  /**
   * Validates the keyholder address, and returns a normalized (i.e. lowercase)
   * copy of it.
   *
   * an error
   */
  async function validateAndNormalizeKeyholder(address, req) {
    if (typeof address === "string" && address.length > 0) {
      // ensure address is included in provided accounts
      const accounts = await getAccounts(req);
      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());
      const normalizedAddress = address.toLowerCase();
      if (normalizedAccounts.includes(normalizedAddress)) {
        return normalizedAddress;
      }
    }
    throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.invalidParams({
      message: `Invalid parameters: must provide an Ethereum address.`
    });
  }

  //
  // account lookups
  //

  async function lookupAccounts(req, res) {
    res.result = await getAccounts(req);
  }

  //
  // transaction signatures
  //

  async function sendTransaction(req, res) {
    if (!processTransaction) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    const txParams = req.params[0] || {
      from: ""
    };
    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
    res.result = await processTransaction(txParams, req);
  }
  async function signTransaction(req, res) {
    if (!processSignTransaction) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    const txParams = req.params[0] || {
      from: ""
    };
    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
    res.result = await processSignTransaction(txParams, req);
  }

  //
  // message signatures
  //

  async function ethSign(req, res) {
    if (!processEthSignMessage) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    let msgParams = req.params;
    const extraParams = req.params[2] || {};
    if (Array.isArray(req.params)) {
      if (!(req.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [address, message]`);
      const params = req.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    msgParams = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, extraParams), msgParams);
    res.result = await processEthSignMessage(msgParams, req);
  }
  async function signTypedDataV4(req, res) {
    if (!processTypedMessageV4) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    if (!(req !== null && req !== void 0 && req.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = req.params;
    if (Array.isArray(req.params)) {
      if (!(req.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [address, typedData]`);
      const params = req.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    res.result = await processTypedMessageV4(msgParams, req);
  }
  async function personalSign(req, res) {
    if (!processPersonalMessage) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    let msgParams = req.params;
    const extraParams = req.params[2] || {};
    if (Array.isArray(req.params)) {
      if (!(req.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [message, address]`);
      const params = req.params;
      if (typeof params[0] === "object") {
        const {
          challenge,
          address
        } = params[0];
        msgParams = {
          from: address,
          data: challenge
        };
      } else {
        const message = params[0];
        const address = params[1];
        msgParams = {
          from: address,
          data: message
        };
      }
    }
    msgParams = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, extraParams), msgParams);
    res.result = await processPersonalMessage(msgParams, req);
  }
  async function fetchPrivateKey(req, res) {
    if (!getPrivateKey) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    res.result = await getPrivateKey(req);
  }
  async function fetchPublicKey(req, res) {
    if (!getPublicKey) {
      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.rpcErrors.methodNotSupported();
    }
    res.result = await getPublicKey(req);
  }
  return (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createScaffoldMiddleware)({
    // account lookups
    eth_accounts: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(lookupAccounts),
    eth_requestAccounts: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(lookupAccounts),
    eth_private_key: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(fetchPrivateKey),
    eth_public_key: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(fetchPublicKey),
    public_key: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(fetchPublicKey),
    private_key: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(fetchPrivateKey),
    // tx signatures
    eth_sendTransaction: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(sendTransaction),
    eth_signTransaction: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(signTransaction),
    // message signatures
    eth_sign: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(ethSign),
    eth_signTypedData_v4: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(signTypedDataV4),
    personal_sign: (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(personalSign)
  });
}

/***/ }),

/***/ 846:
/***/ ((module) => {

"use strict";
module.exports = require("@babel/runtime/helpers/objectSpread2");

/***/ }),

/***/ 885:
/***/ ((module) => {

"use strict";
module.exports = require("@toruslabs/base-controllers");

/***/ }),

/***/ 894:
/***/ ((module) => {

"use strict";
module.exports = require("@web3auth/auth");

/***/ }),

/***/ 999:
/***/ ((module) => {

"use strict";
module.exports = require("ethers");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EIP1559APIEndpoint: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.ux),
/* harmony export */   EthereumPrivateKeyProvider: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.Bl),
/* harmony export */   GAS_ESTIMATE_TYPES: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.ve),
/* harmony export */   LegacyGasAPIEndpoint: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.Og),
/* harmony export */   SignTypedDataVersion: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.aU),
/* harmony export */   TRANSACTION_ENVELOPE_TYPES: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.yH),
/* harmony export */   TRANSACTION_TYPES: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.t2),
/* harmony export */   TransactionFormatter: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.NX),
/* harmony export */   fetchEip1159GasEstimates: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.r8),
/* harmony export */   fetchLegacyGasPriceEstimates: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.hY),
/* harmony export */   getProviderHandlers: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.b6),
/* harmony export */   normalizeGWEIDecimalNumbers: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.vo),
/* harmony export */   validateAddress: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.jl),
/* harmony export */   validateTypedSignMessageDataV4: () => (/* reexport safe */ _providers__WEBPACK_IMPORTED_MODULE_0__.lG)
/* harmony export */ });
/* harmony import */ var _providers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(845);
/* harmony import */ var _rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _rpc__WEBPACK_IMPORTED_MODULE_1__) if(["default","EIP1559APIEndpoint","EthereumPrivateKeyProvider","GAS_ESTIMATE_TYPES","LegacyGasAPIEndpoint","SignTypedDataVersion","TRANSACTION_ENVELOPE_TYPES","TRANSACTION_TYPES","TransactionFormatter","fetchEip1159GasEstimates","fetchLegacyGasPriceEstimates","getProviderHandlers","normalizeGWEIDecimalNumbers","validateAddress","validateTypedSignMessageDataV4"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _rpc__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


})();

module.exports = __webpack_exports__;
/******/ })()
;