'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var util = require('@ethereumjs/util');
var baseControllers = require('@toruslabs/base-controllers');
var eccrypto = require('@toruslabs/eccrypto');
var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var ethers = require('ethers');
var viem = require('viem');
var utils = require('./TransactionFormatter/utils.js');

async function signTx(txParams, privKey, txFormatter) {
  const finalTxParams = await txFormatter.formatTransaction(txParams);
  const {
    Transaction
  } = await import('ethers');
  const ethTx = Transaction.from(_objectSpread(_objectSpread({}, finalTxParams), {}, {
    from: undefined // from is already calculated inside Transaction.from and is not allowed to be passed in
  }));
  const signKey = new ethers.SigningKey(util.addHexPrefix(privKey));
  ethTx.signature = signKey.sign(ethTx.unsignedHash);
  return ethTx.serialized;
}
function getProviderHandlers({
  txFormatter,
  privKey,
  keyExportEnabled,
  getProviderEngineProxy
}) {
  return {
    getAccounts: async _ => [`0x${Buffer.from(util.privateToAddress(Buffer.from(privKey, "hex"))).toString("hex")}`],
    getPublicKey: async _ => {
      const publicKey = eccrypto.getPublicCompressed(Buffer.from(util.stripHexPrefix(privKey), "hex"));
      return `0x${Buffer.from(publicKey).toString("hex")}`;
    },
    getPrivateKey: async _ => {
      if (!keyExportEnabled) throw auth.providerErrors.custom({
        message: "Private key export is disabled",
        code: 4902
      });
      return privKey;
    },
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      if (txParams.input && !txParams.data) txParams.data = util.addHexPrefix(txParams.input);
      const serializedTx = await signTx(txParams, privKey, txFormatter);
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: [serializedTx]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      if (txParams.input && !txParams.data) txParams.data = util.addHexPrefix(txParams.input);
      const serializedTx = await signTx(txParams, privKey, txFormatter);
      return serializedTx;
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = baseControllers.signMessage(privKey, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const ethersKey = new ethers.SigningKey(privKeyBuffer);
      const {
        data
      } = msgParams;
      // we need to check if the data is hex or not
      // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
      // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
      const message = util.isHexString(data) ? Buffer.from(util.stripHexPrefix(data), "hex") : Buffer.from(data);
      const signature = ethersKey.sign(ethers.hashMessage(message));
      return signature.serialized;
    },
    processTypedMessageV4: async (msgParams, _) => {
      base.log.debug("processTypedMessageV4", msgParams);
      const privKeyBuffer = Buffer.from(privKey, "hex");
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const chainId = await providerEngineProxy.request({
        method: "eth_chainId"
      });
      await utils.validateTypedSignMessageDataV4(msgParams, chainId);
      const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
      const ethersPrivateKey = new ethers.SigningKey(privKeyBuffer);
      viem.validateTypedData(data);
      const signature = ethersPrivateKey.sign(viem.hashTypedData(data)).serialized;
      return signature;
    }
  };
}

exports.getProviderHandlers = getProviderHandlers;
