import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { mergeMiddleware, createAsyncMiddleware, providerErrors, rpcErrors, JRPCEngine, providerFromEngine } from '@web3auth/auth';
import { CHAIN_NAMESPACES, WalletInitializationError } from '@web3auth/base';
import { BaseProvider } from '@web3auth/base-provider';
import { randomId, createFetchMiddleware } from '@toruslabs/base-controllers';
import { sign, generateSeed } from 'ripple-keypairs';
import { Client, deriveAddress, Wallet } from 'xrpl';
import ECDSA from 'xrpl/dist/npm/ECDSA';

const RPC_METHODS = {
  GET_ACCOUNTS: "xrpl_getAccounts",
  GET_KEY_PAIR: "xrpl_getKeyPair",
  GET_PUBLIC_KEY: "xrpl_getPublicKey",
  SIGN_MESSAGE: "xrpl_signMessage",
  SIGN_TRANSACTION: "xrpl_signTransaction",
  SUBMIT_TRANSACTION: "xrpl_submitTransaction",
  ADD_CHAIN: "xrpl_addChain",
  SWITCH_CHAIN: "xrpl_switchChain",
  CHAIN_ID: "xrpl_chainId",
  PROVIDER_CHAIN_CONFIG: "xrpl_providerChainConfig"
};
function createGetAccountsMiddleware({
  getAccounts
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;

    // hack to override big ids from fetch middleware which are not supported in xrpl servers
    // TODO: fix this for xrpl controllers.
    request.id = randomId();
    if (method !== RPC_METHODS.GET_ACCOUNTS) return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    // This calls from the prefs controller
    const accounts = await getAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createGenericJRPCMiddleware(targetMethod, handler) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== targetMethod) return next();
    if (!handler) throw new Error(`WalletMiddleware - ${targetMethod} not provided`);
    const result = await handler(request);
    response.result = result;
    return undefined;
  });
}
function createXRPLMiddleware(providerHandlers) {
  const {
    getAccounts,
    submitTransaction,
    signTransaction,
    signMessage,
    getKeyPair,
    getPublicKey
  } = providerHandlers;
  return mergeMiddleware([createGetAccountsMiddleware({
    getAccounts
  }), createGenericJRPCMiddleware(RPC_METHODS.SIGN_TRANSACTION, signTransaction), createGenericJRPCMiddleware(RPC_METHODS.SUBMIT_TRANSACTION, submitTransaction), createGenericJRPCMiddleware(RPC_METHODS.SIGN_MESSAGE, signMessage), createGenericJRPCMiddleware(RPC_METHODS.GET_KEY_PAIR, getKeyPair), createGenericJRPCMiddleware(RPC_METHODS.GET_PUBLIC_KEY, getPublicKey)]);
}
function createChainSwitchMiddleware({
  addChainConfig,
  switchChain
}) {
  return mergeMiddleware([createGenericJRPCMiddleware(RPC_METHODS.ADD_CHAIN, addChainConfig), createGenericJRPCMiddleware(RPC_METHODS.SWITCH_CHAIN, switchChain)]);
}

function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === RPC_METHODS.CHAIN_ID) {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === RPC_METHODS.PROVIDER_CHAIN_CONFIG) {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createConfigMiddleware(providerConfig) {
  const {
    chainId
  } = providerConfig;
  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);
}
function createJsonRpcClient(providerConfig) {
  const {
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = createFetchMiddleware({
    rpcTarget
  });
  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}

const deriveKeypair = web3authKey => {
  const seed = generateSeed({
    entropy: Buffer.from(web3authKey.padStart(64, "0"), "hex"),
    algorithm: "ecdsa-secp256k1"
  });
  const wallet = Wallet.fromSecret(seed, {
    algorithm: ECDSA.secp256k1
  }); // web3auth network currently only supports the secp256k1 key
  return {
    privateKey: wallet.privateKey,
    publicKey: wallet.publicKey
  };
};
async function getProviderHandlers({
  privKey: web3authKey,
  chainConfig,
  keyExportEnabled
}) {
  const client = new Client(chainConfig.wsTarget);
  await client.connect();
  return {
    getAccounts: async _ => {
      const {
        publicKey
      } = deriveKeypair(web3authKey);
      const accAddress = deriveAddress(publicKey);
      return [accAddress];
    },
    getKeyPair: async _ => {
      if (!keyExportEnabled) throw providerErrors.custom({
        message: "Private key export is disabled",
        code: 4902
      });
      return deriveKeypair(web3authKey);
    },
    getPublicKey: async _ => {
      const keyPair = deriveKeypair(web3authKey);
      return keyPair.publicKey;
    },
    signTransaction: async req => {
      const {
        transaction,
        multisign
      } = req.params || {};
      if (!transaction) throw rpcErrors.invalidParams("Invalid params, req.params.transaction is required");
      const {
        publicKey,
        privateKey
      } = deriveKeypair(web3authKey);
      const wallet = new Wallet(publicKey, privateKey);
      return wallet.sign(transaction, multisign);
    },
    submitTransaction: async req => {
      const {
        transaction
      } = req.params || {};
      if (!transaction) throw rpcErrors.invalidParams("Invalid params, req.params.transaction is required");
      const {
        publicKey,
        privateKey
      } = deriveKeypair(web3authKey);
      const wallet = new Wallet(publicKey, privateKey);
      const res = await client.submit(transaction, {
        wallet
      });
      return res;
    },
    signMessage: async req => {
      const {
        message
      } = req.params || {};
      if (!message) throw rpcErrors.invalidParams("Invalid params, req.params.message is required");
      const keyPair = deriveKeypair(web3authKey);
      const signature = sign(message, keyPair.privateKey);
      return {
        signature
      };
    }
  };
}

var _XrplPrivateKeyProvider;
class XrplPrivateKeyProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", CHAIN_NAMESPACES.XRPL);
  }
  async enable() {
    if (!this.state.privateKey) throw providerErrors.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: RPC_METHODS.GET_ACCOUNTS
    });
  }
  async setupProvider(privKey) {
    const {
      wsTarget,
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    if (!wsTarget) {
      throw WalletInitializationError.invalidParams(`wsTarget is required in chainConfig for xrplProvider`);
    }
    const providerHandlers = await getProviderHandlers({
      privKey,
      chainConfig: this.config.chainConfig,
      keyExportEnabled: this.config.keyExportEnabled
    });
    const xrplWalletMiddleware = createXRPLMiddleware(providerHandlers);
    const engine = new JRPCEngine();
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(this.getChainSwitchMiddleware());
    engine.push(xrplWalletMiddleware);
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const {
      privateKey
    } = await this._providerEngineProxy.request({
      method: RPC_METHODS.GET_KEY_PAIR
    });
    await this.setupProvider(privateKey);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const pingResponse = await this._providerEngineProxy.request({
      method: "ping",
      params: []
    });
    if ((pingResponse === null || pingResponse === void 0 ? void 0 : pingResponse.status) !== "success") {
      const {
        chainConfig
      } = this.config;
      throw WalletInitializationError.rpcConnectionError(`Failed to ping network for following rpc target: ${chainConfig.rpcTarget}`);
    }
    if (this.state.chainId !== chainId) {
      this.emit("chainChanged", chainId);
      this.emit("connect", {
        chainId
      });
    }
    this.update({
      chainId
    });
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChainConfig: async req => {
        if (!req.params) throw rpcErrors.invalidParams("Missing request params");
        const {
          chainId,
          ticker,
          tickerName,
          displayName,
          rpcTarget,
          wsTarget,
          blockExplorerUrl,
          logo
        } = req.params;
        if (!chainId) throw rpcErrors.invalidParams("Missing chainId in chainParams");
        if (!rpcTarget) throw rpcErrors.invalidParams("Missing rpcTarget in chainParams");
        if (!wsTarget) throw rpcErrors.invalidParams("Missing wsTarget in chainParams");
        this.addChain({
          chainNamespace: CHAIN_NAMESPACES.XRPL,
          chainId,
          ticker: ticker || "XRP",
          tickerName: tickerName || "XRPL",
          displayName: displayName || "XRPL",
          rpcTarget,
          wsTarget,
          blockExplorerUrl,
          logo
        });
      },
      switchChain: async req => {
        if (!req.params) throw rpcErrors.invalidParams("Missing request params");
        if (!req.params.chainId) throw rpcErrors.invalidParams("Missing chainId");
        await this.switchChain(req.params);
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
}
_XrplPrivateKeyProvider = XrplPrivateKeyProvider;
_defineProperty(XrplPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _XrplPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});

export { XrplPrivateKeyProvider, getProviderHandlers };
