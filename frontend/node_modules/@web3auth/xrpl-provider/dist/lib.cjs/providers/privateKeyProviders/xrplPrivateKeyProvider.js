'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var baseProvider = require('@web3auth/base-provider');
var JrpcClient = require('../../rpc/JrpcClient.js');
var xrplRpcMiddlewares = require('../../rpc/xrplRpcMiddlewares.js');
var xrplWalletUtils = require('./xrplWalletUtils.js');

var _XrplPrivateKeyProvider;
class XrplPrivateKeyProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", base.CHAIN_NAMESPACES.XRPL);
  }
  async enable() {
    if (!this.state.privateKey) throw auth.providerErrors.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: xrplRpcMiddlewares.RPC_METHODS.GET_ACCOUNTS
    });
  }
  async setupProvider(privKey) {
    const {
      wsTarget,
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    if (!wsTarget) {
      throw base.WalletInitializationError.invalidParams(`wsTarget is required in chainConfig for xrplProvider`);
    }
    const providerHandlers = await xrplWalletUtils.getProviderHandlers({
      privKey,
      chainConfig: this.config.chainConfig,
      keyExportEnabled: this.config.keyExportEnabled
    });
    const xrplWalletMiddleware = xrplRpcMiddlewares.createXRPLMiddleware(providerHandlers);
    const engine = new auth.JRPCEngine();
    const {
      networkMiddleware
    } = JrpcClient.createJsonRpcClient(this.config.chainConfig);
    engine.push(this.getChainSwitchMiddleware());
    engine.push(xrplWalletMiddleware);
    engine.push(networkMiddleware);
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const {
      privateKey
    } = await this._providerEngineProxy.request({
      method: xrplRpcMiddlewares.RPC_METHODS.GET_KEY_PAIR
    });
    await this.setupProvider(privateKey);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw auth.rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const pingResponse = await this._providerEngineProxy.request({
      method: "ping",
      params: []
    });
    if ((pingResponse === null || pingResponse === void 0 ? void 0 : pingResponse.status) !== "success") {
      const {
        chainConfig
      } = this.config;
      throw base.WalletInitializationError.rpcConnectionError(`Failed to ping network for following rpc target: ${chainConfig.rpcTarget}`);
    }
    if (this.state.chainId !== chainId) {
      this.emit("chainChanged", chainId);
      this.emit("connect", {
        chainId
      });
    }
    this.update({
      chainId
    });
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChainConfig: async req => {
        if (!req.params) throw auth.rpcErrors.invalidParams("Missing request params");
        const {
          chainId,
          ticker,
          tickerName,
          displayName,
          rpcTarget,
          wsTarget,
          blockExplorerUrl,
          logo
        } = req.params;
        if (!chainId) throw auth.rpcErrors.invalidParams("Missing chainId in chainParams");
        if (!rpcTarget) throw auth.rpcErrors.invalidParams("Missing rpcTarget in chainParams");
        if (!wsTarget) throw auth.rpcErrors.invalidParams("Missing wsTarget in chainParams");
        this.addChain({
          chainNamespace: base.CHAIN_NAMESPACES.XRPL,
          chainId,
          ticker: ticker || "XRP",
          tickerName: tickerName || "XRPL",
          displayName: displayName || "XRPL",
          rpcTarget,
          wsTarget,
          blockExplorerUrl,
          logo
        });
      },
      switchChain: async req => {
        if (!req.params) throw auth.rpcErrors.invalidParams("Missing request params");
        if (!req.params.chainId) throw auth.rpcErrors.invalidParams("Missing chainId");
        await this.switchChain(req.params);
      }
    };
    const chainSwitchMiddleware = xrplRpcMiddlewares.createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
}
_XrplPrivateKeyProvider = XrplPrivateKeyProvider;
_defineProperty(XrplPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _XrplPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});

exports.XrplPrivateKeyProvider = XrplPrivateKeyProvider;
