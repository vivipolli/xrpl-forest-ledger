/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 524:
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
var ECDSA;
(function (ECDSA) {
    ECDSA["ed25519"] = "ed25519";
    ECDSA["secp256k1"] = "ecdsa-secp256k1";
})(ECDSA || (ECDSA = {}));
exports.A = ECDSA;
//# sourceMappingURL=ECDSA.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  XrplPrivateKeyProvider: () => (/* reexport */ XrplPrivateKeyProvider),
  getProviderHandlers: () => (/* reexport */ getProviderHandlers)
});

;// external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// external "@web3auth/auth"
const auth_namespaceObject = require("@web3auth/auth");
;// external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// external "@web3auth/base-provider"
const base_provider_namespaceObject = require("@web3auth/base-provider");
;// external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
;// ./src/rpc/xrplRpcMiddlewares.ts


const RPC_METHODS = {
  GET_ACCOUNTS: "xrpl_getAccounts",
  GET_KEY_PAIR: "xrpl_getKeyPair",
  GET_PUBLIC_KEY: "xrpl_getPublicKey",
  SIGN_MESSAGE: "xrpl_signMessage",
  SIGN_TRANSACTION: "xrpl_signTransaction",
  SUBMIT_TRANSACTION: "xrpl_submitTransaction",
  ADD_CHAIN: "xrpl_addChain",
  SWITCH_CHAIN: "xrpl_switchChain",
  CHAIN_ID: "xrpl_chainId",
  PROVIDER_CHAIN_CONFIG: "xrpl_providerChainConfig"
};
function createGetAccountsMiddleware({
  getAccounts
}) {
  return (0,auth_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;

    // hack to override big ids from fetch middleware which are not supported in xrpl servers
    // TODO: fix this for xrpl controllers.
    request.id = (0,base_controllers_namespaceObject.randomId)();
    if (method !== RPC_METHODS.GET_ACCOUNTS) return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    // This calls from the prefs controller
    const accounts = await getAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createGenericJRPCMiddleware(targetMethod, handler) {
  return (0,auth_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== targetMethod) return next();
    if (!handler) throw new Error(`WalletMiddleware - ${targetMethod} not provided`);
    const result = await handler(request);
    response.result = result;
    return undefined;
  });
}
function createXRPLMiddleware(providerHandlers) {
  const {
    getAccounts,
    submitTransaction,
    signTransaction,
    signMessage,
    getKeyPair,
    getPublicKey
  } = providerHandlers;
  return (0,auth_namespaceObject.mergeMiddleware)([createGetAccountsMiddleware({
    getAccounts
  }), createGenericJRPCMiddleware(RPC_METHODS.SIGN_TRANSACTION, signTransaction), createGenericJRPCMiddleware(RPC_METHODS.SUBMIT_TRANSACTION, submitTransaction), createGenericJRPCMiddleware(RPC_METHODS.SIGN_MESSAGE, signMessage), createGenericJRPCMiddleware(RPC_METHODS.GET_KEY_PAIR, getKeyPair), createGenericJRPCMiddleware(RPC_METHODS.GET_PUBLIC_KEY, getPublicKey)]);
}
function createChainSwitchMiddleware({
  addChainConfig,
  switchChain
}) {
  return (0,auth_namespaceObject.mergeMiddleware)([createGenericJRPCMiddleware(RPC_METHODS.ADD_CHAIN, addChainConfig), createGenericJRPCMiddleware(RPC_METHODS.SWITCH_CHAIN, switchChain)]);
}
;// ./src/rpc/JrpcClient.ts



function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === RPC_METHODS.CHAIN_ID) {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === RPC_METHODS.PROVIDER_CHAIN_CONFIG) {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createConfigMiddleware(providerConfig) {
  const {
    chainId
  } = providerConfig;
  return (0,auth_namespaceObject.mergeMiddleware)([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);
}
function createJsonRpcClient(providerConfig) {
  const {
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = (0,base_controllers_namespaceObject.createFetchMiddleware)({
    rpcTarget
  });
  const networkMiddleware = (0,auth_namespaceObject.mergeMiddleware)([createConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
;// external "ripple-keypairs"
const external_ripple_keypairs_namespaceObject = require("ripple-keypairs");
;// external "xrpl"
const external_xrpl_namespaceObject = require("xrpl");
// EXTERNAL MODULE: ../../../node_modules/xrpl/dist/npm/ECDSA.js
var ECDSA = __webpack_require__(524);
;// ./src/providers/privateKeyProviders/xrplWalletUtils.ts




const deriveKeypair = web3authKey => {
  const seed = (0,external_ripple_keypairs_namespaceObject.generateSeed)({
    entropy: Buffer.from(web3authKey.padStart(64, "0"), "hex"),
    algorithm: "ecdsa-secp256k1"
  });
  const wallet = external_xrpl_namespaceObject.Wallet.fromSecret(seed, {
    algorithm: ECDSA/* default */.A.secp256k1
  }); // web3auth network currently only supports the secp256k1 key
  return {
    privateKey: wallet.privateKey,
    publicKey: wallet.publicKey
  };
};
async function getProviderHandlers({
  privKey: web3authKey,
  chainConfig,
  keyExportEnabled
}) {
  const client = new external_xrpl_namespaceObject.Client(chainConfig.wsTarget);
  await client.connect();
  return {
    getAccounts: async _ => {
      const {
        publicKey
      } = deriveKeypair(web3authKey);
      const accAddress = (0,external_xrpl_namespaceObject.deriveAddress)(publicKey);
      return [accAddress];
    },
    getKeyPair: async _ => {
      if (!keyExportEnabled) throw auth_namespaceObject.providerErrors.custom({
        message: "Private key export is disabled",
        code: 4902
      });
      return deriveKeypair(web3authKey);
    },
    getPublicKey: async _ => {
      const keyPair = deriveKeypair(web3authKey);
      return keyPair.publicKey;
    },
    signTransaction: async req => {
      const {
        transaction,
        multisign
      } = req.params || {};
      if (!transaction) throw auth_namespaceObject.rpcErrors.invalidParams("Invalid params, req.params.transaction is required");
      const {
        publicKey,
        privateKey
      } = deriveKeypair(web3authKey);
      const wallet = new external_xrpl_namespaceObject.Wallet(publicKey, privateKey);
      return wallet.sign(transaction, multisign);
    },
    submitTransaction: async req => {
      const {
        transaction
      } = req.params || {};
      if (!transaction) throw auth_namespaceObject.rpcErrors.invalidParams("Invalid params, req.params.transaction is required");
      const {
        publicKey,
        privateKey
      } = deriveKeypair(web3authKey);
      const wallet = new external_xrpl_namespaceObject.Wallet(publicKey, privateKey);
      const res = await client.submit(transaction, {
        wallet
      });
      return res;
    },
    signMessage: async req => {
      const {
        message
      } = req.params || {};
      if (!message) throw auth_namespaceObject.rpcErrors.invalidParams("Invalid params, req.params.message is required");
      const keyPair = deriveKeypair(web3authKey);
      const signature = (0,external_ripple_keypairs_namespaceObject.sign)(message, keyPair.privateKey);
      return {
        signature
      };
    }
  };
}
;// ./src/providers/privateKeyProviders/xrplPrivateKeyProvider.ts

var _XrplPrivateKeyProvider;






class XrplPrivateKeyProvider extends base_provider_namespaceObject.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "PROVIDER_CHAIN_NAMESPACE", base_namespaceObject.CHAIN_NAMESPACES.XRPL);
  }
  async enable() {
    if (!this.state.privateKey) throw auth_namespaceObject.providerErrors.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: RPC_METHODS.GET_ACCOUNTS
    });
  }
  async setupProvider(privKey) {
    const {
      wsTarget,
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base_namespaceObject.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    if (!wsTarget) {
      throw base_namespaceObject.WalletInitializationError.invalidParams(`wsTarget is required in chainConfig for xrplProvider`);
    }
    const providerHandlers = await getProviderHandlers({
      privKey,
      chainConfig: this.config.chainConfig,
      keyExportEnabled: this.config.keyExportEnabled
    });
    const xrplWalletMiddleware = createXRPLMiddleware(providerHandlers);
    const engine = new auth_namespaceObject.JRPCEngine();
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(this.getChainSwitchMiddleware());
    engine.push(xrplWalletMiddleware);
    engine.push(networkMiddleware);
    const provider = (0,auth_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const {
      privateKey
    } = await this._providerEngineProxy.request({
      method: RPC_METHODS.GET_KEY_PAIR
    });
    await this.setupProvider(privateKey);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw auth_namespaceObject.rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const pingResponse = await this._providerEngineProxy.request({
      method: "ping",
      params: []
    });
    if ((pingResponse === null || pingResponse === void 0 ? void 0 : pingResponse.status) !== "success") {
      const {
        chainConfig
      } = this.config;
      throw base_namespaceObject.WalletInitializationError.rpcConnectionError(`Failed to ping network for following rpc target: ${chainConfig.rpcTarget}`);
    }
    if (this.state.chainId !== chainId) {
      this.emit("chainChanged", chainId);
      this.emit("connect", {
        chainId
      });
    }
    this.update({
      chainId
    });
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChainConfig: async req => {
        if (!req.params) throw auth_namespaceObject.rpcErrors.invalidParams("Missing request params");
        const {
          chainId,
          ticker,
          tickerName,
          displayName,
          rpcTarget,
          wsTarget,
          blockExplorerUrl,
          logo
        } = req.params;
        if (!chainId) throw auth_namespaceObject.rpcErrors.invalidParams("Missing chainId in chainParams");
        if (!rpcTarget) throw auth_namespaceObject.rpcErrors.invalidParams("Missing rpcTarget in chainParams");
        if (!wsTarget) throw auth_namespaceObject.rpcErrors.invalidParams("Missing wsTarget in chainParams");
        this.addChain({
          chainNamespace: base_namespaceObject.CHAIN_NAMESPACES.XRPL,
          chainId,
          ticker: ticker || "XRP",
          tickerName: tickerName || "XRPL",
          displayName: displayName || "XRPL",
          rpcTarget,
          wsTarget,
          blockExplorerUrl,
          logo
        });
      },
      switchChain: async req => {
        if (!req.params) throw auth_namespaceObject.rpcErrors.invalidParams("Missing request params");
        if (!req.params.chainId) throw auth_namespaceObject.rpcErrors.invalidParams("Missing chainId");
        await this.switchChain(req.params);
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
}
_XrplPrivateKeyProvider = XrplPrivateKeyProvider;
defineProperty_default()(XrplPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _XrplPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});
;// ./src/providers/privateKeyProviders/index.ts



;// ./src/providers/index.ts

;// ./src/index.ts

module.exports = __webpack_exports__;
/******/ })()
;