/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  InitializationError: () => (/* reexport */ InitializationError),
  LoginError: () => (/* reexport */ LoginError),
  OpenloginError: () => (/* reexport */ OpenloginError),
  constructURL: () => (/* reexport */ constructURL),
  "default": () => (/* reexport */ src_OpenLogin),
  getHashQueryParams: () => (/* reexport */ getHashQueryParams),
  getPopupFeatures: () => (/* reexport */ getPopupFeatures),
  getTimeout: () => (/* reexport */ getTimeout),
  isMobileOrTablet: () => (/* reexport */ isMobileOrTablet),
  loglevel: () => (/* reexport */ loglevel),
  version: () => (/* reexport */ version),
  whitelistUrl: () => (/* reexport */ whitelistUrl)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "ts-custom-error"
const external_ts_custom_error_namespaceObject = require("ts-custom-error");
;// CONCATENATED MODULE: ./src/errors.ts


class OpenloginError extends external_ts_custom_error_namespaceObject.CustomError {
  constructor(code, message) {
    // takes care of stack and proto
    super(message);
    defineProperty_default()(this, "code", void 0);
    defineProperty_default()(this, "message", void 0);
    this.code = code;
    this.message = message || "";
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "OpenloginError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class InitializationError extends OpenloginError {
  constructor(code, message) {
    // takes care of stack and proto
    super(code, message);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "InitializationError"
    });
  }
  static fromCode(code) {
    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    return new InitializationError(code, `${InitializationError.messages[code]}, ${extraMessage}`);
  }
  static invalidParams() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return InitializationError.fromCode(5001, extraMessage);
  }
  static notInitialized() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return InitializationError.fromCode(5002, extraMessage);
  }
}

/**
 * login errors
 */
defineProperty_default()(InitializationError, "messages", {
  5000: "Custom",
  5001: "Invalid constructor params",
  5002: "SDK not initialized. please call init first"
});
class LoginError extends OpenloginError {
  constructor(code, message) {
    // takes care of stack and proto
    super(code, message);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "LoginError"
    });
  }
  static fromCode(code) {
    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    return new LoginError(code, `${LoginError.messages[code]}, ${extraMessage}`);
  }
  static invalidLoginParams() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5111, extraMessage);
  }
  static userNotLoggedIn() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5112, extraMessage);
  }
  static popupClosed() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5113, extraMessage);
  }
  static loginFailed() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5114, extraMessage);
  }
  static popupBlocked() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5115, extraMessage);
  }
  static mfaAlreadyEnabled() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5116, extraMessage);
  }
  static mfaNotEnabled() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return LoginError.fromCode(5117, extraMessage);
  }
}
defineProperty_default()(LoginError, "messages", {
  5000: "Custom",
  5111: "Invalid login params",
  5112: "User not logged in.",
  5113: "login popup has been closed by the user",
  5114: "Login failed",
  5115: "Popup was blocked. Please call this function as soon as user clicks button or use redirect mode",
  5116: "MFA already enabled",
  5117: "MFA not yet enabled. Please call `enableMFA` first"
});
;// CONCATENATED MODULE: external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
;// CONCATENATED MODULE: ./src/logger.ts

const loglevel = (0,external_loglevel_namespaceObject.getLogger)("openlogin");
loglevel.setLevel("error");
;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/constants"
const constants_namespaceObject = require("@toruslabs/constants");
;// CONCATENATED MODULE: external "@toruslabs/openlogin-session-manager"
const openlogin_session_manager_namespaceObject = require("@toruslabs/openlogin-session-manager");
;// CONCATENATED MODULE: external "@toruslabs/openlogin-utils"
const openlogin_utils_namespaceObject = require("@toruslabs/openlogin-utils");
;// CONCATENATED MODULE: external "@toruslabs/secure-pub-sub"
const secure_pub_sub_namespaceObject = require("@toruslabs/secure-pub-sub");
;// CONCATENATED MODULE: external "events"
const external_events_namespaceObject = require("events");
;// CONCATENATED MODULE: external "@toruslabs/eccrypto"
const eccrypto_namespaceObject = require("@toruslabs/eccrypto");
;// CONCATENATED MODULE: external "@toruslabs/metadata-helpers"
const metadata_helpers_namespaceObject = require("@toruslabs/metadata-helpers");
;// CONCATENATED MODULE: external "bowser"
const external_bowser_namespaceObject = require("bowser");
var external_bowser_default = /*#__PURE__*/__webpack_require__.n(external_bowser_namespaceObject);
;// CONCATENATED MODULE: ./src/utils.ts







// don't use destructuring for process.env cause it messes up webpack env plugin
const version = "8.2.1";
async function whitelistUrl(clientId, appKey, origin) {
  const appKeyBuf = Buffer.from(appKey.padStart(64, "0"), "hex");
  if (openlogin_utils_namespaceObject.base64url.encode((0,eccrypto_namespaceObject.getPublic)(appKeyBuf)) !== clientId) throw new Error("appKey mismatch");
  const sig = await (0,eccrypto_namespaceObject.sign)(appKeyBuf, (0,metadata_helpers_namespaceObject.keccak256)(Buffer.from(origin, "utf8")));
  return openlogin_utils_namespaceObject.base64url.encode(sig);
}
function getHashQueryParams() {
  let replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  const result = {};
  const queryUrlParams = new URLSearchParams(window.location.search.slice(1));
  queryUrlParams.forEach((value, key) => {
    if (key !== "b64Params") {
      result[key] = value;
    }
  });
  const queryResult = queryUrlParams.get("b64Params");
  if (queryResult) {
    try {
      const queryParams = JSON.parse((0,openlogin_utils_namespaceObject.safeatob)(queryResult));
      Object.keys(queryParams).forEach(key => {
        result[key] = queryParams[key];
      });
    } catch (error) {
      loglevel.error(error);
    }
  }
  const hashUrlParams = new URLSearchParams(window.location.hash.substring(1));
  hashUrlParams.forEach((value, key) => {
    if (key !== "b64Params") {
      result[key] = value;
    }
  });
  const hashResult = hashUrlParams.get("b64Params");
  if (hashResult) {
    try {
      const hashParams = JSON.parse((0,openlogin_utils_namespaceObject.safeatob)(hashResult));
      Object.keys(hashParams).forEach(key => {
        result[key] = hashParams[key];
      });
    } catch (error) {
      loglevel.error(error);
    }
  }
  if (replaceUrl) {
    const cleanUrl = new URL(window.location.origin + window.location.pathname);
    // https://dapp.com/#b64Params=asacsdnvdfv&state=sldjvndfkjvn&dappValue=sdjvndf
    if (queryUrlParams.size > 0) {
      queryUrlParams.delete("error");
      queryUrlParams.delete("state");
      queryUrlParams.delete("b64Params");
      queryUrlParams.delete("sessionNamespace");
      cleanUrl.search = queryUrlParams.toString();
    }
    if (hashUrlParams.size > 0) {
      hashUrlParams.delete("error");
      hashUrlParams.delete("state");
      hashUrlParams.delete("b64Params");
      hashUrlParams.delete("sessionNamespace");
      cleanUrl.hash = hashUrlParams.toString();
    }
    window.history.replaceState(objectSpread2_default()(objectSpread2_default()({}, window.history.state), {}, {
      as: cleanUrl.href,
      url: cleanUrl.href
    }), "", cleanUrl.href);
  }
  return result;
}
function constructURL(params) {
  const {
    baseURL,
    query,
    hash
  } = params;
  const url = new URL(baseURL);
  if (query) {
    Object.keys(query).forEach(key => {
      url.searchParams.append(key, query[key]);
    });
  }
  if (hash) {
    const h = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h;
  }
  return url.toString();
}
function getPopupFeatures() {
  if (typeof window === "undefined") return "";
  // Fixes dual-screen position                             Most browsers      Firefox
  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  const w = 1200;
  const h = 700;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1; // No reliable estimate

  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
  return features;
}
function isMobileOrTablet() {
  if (typeof window === "undefined") return false;
  const browser = external_bowser_default().getParser(window.navigator.userAgent);
  const platform = browser.getPlatform();
  return platform.type === (external_bowser_default()).PLATFORMS_MAP.tablet || platform.type === (external_bowser_default()).PLATFORMS_MAP.mobile;
}
function getTimeout(loginProvider) {
  if ((loginProvider === openlogin_utils_namespaceObject.LOGIN_PROVIDER.FACEBOOK || loginProvider === openlogin_utils_namespaceObject.LOGIN_PROVIDER.LINE) && isMobileOrTablet()) {
    return 1000 * 60 * 5; // 5 minutes to finish the login
  }
  return 1000 * 10; // 10 seconds
}
;// CONCATENATED MODULE: ./src/PopupHandler.ts





class PopupHandler extends external_events_namespaceObject.EventEmitter {
  constructor(_ref) {
    let {
      url,
      target,
      features,
      timeout = 30000
    } = _ref;
    super();
    defineProperty_default()(this, "url", void 0);
    defineProperty_default()(this, "target", void 0);
    defineProperty_default()(this, "features", void 0);
    defineProperty_default()(this, "window", void 0);
    defineProperty_default()(this, "windowTimer", void 0);
    defineProperty_default()(this, "iClosedWindow", void 0);
    defineProperty_default()(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures();
    this.window = undefined;
    this.windowTimer = undefined;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = undefined;
        }, this.timeout);
      }
      if (this.window === undefined) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url, this.target, this.features);
    if (!this.window) throw LoginError.popupBlocked();
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url);
    } else {
      window.location.href = this.url;
    }
  }
  async listenOnChannel(loginId) {
    const securePubSub = new secure_pub_sub_namespaceObject.SecurePubSub();
    const data = await securePubSub.subscribe(loginId);
    this.close();
    securePubSub.cleanup();
    const parsedData = JSON.parse(data);
    if (parsedData.error) {
      return {
        error: parsedData.error,
        state: parsedData.state
      };
    }
    return parsedData.data;
  }
}
/* harmony default export */ const src_PopupHandler = (PopupHandler);
;// CONCATENATED MODULE: ./src/OpenLogin.ts









class OpenLogin {
  constructor(options) {
    defineProperty_default()(this, "state", {});
    defineProperty_default()(this, "options", void 0);
    defineProperty_default()(this, "sessionManager", void 0);
    defineProperty_default()(this, "currentStorage", void 0);
    defineProperty_default()(this, "_storageBaseKey", "openlogin_store");
    defineProperty_default()(this, "dappState", void 0);
    defineProperty_default()(this, "addVersionInUrls", true);
    if (!options.clientId) throw InitializationError.invalidParams("clientId is required");
    if (!options.network) options.network = openlogin_utils_namespaceObject.OPENLOGIN_NETWORK.SAPPHIRE_MAINNET;
    if (!options.buildEnv) options.buildEnv = openlogin_utils_namespaceObject.BUILD_ENV.PRODUCTION;
    if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.DEVELOPMENT || options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.TESTING || options.sdkUrl) this.addVersionInUrls = false;
    if (!options.sdkUrl && !options.useMpc) {
      if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.DEVELOPMENT) {
        options.sdkUrl = "http://localhost:3000";
        options.dashboardUrl = "http://localhost:5173/wallet/account";
      } else if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.STAGING) {
        options.sdkUrl = "https://staging-auth.web3auth.io";
        options.dashboardUrl = "https://staging-account.web3auth.io/wallet/account";
      } else if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.TESTING) {
        options.sdkUrl = "https://develop-auth.web3auth.io";
        options.dashboardUrl = "https://develop-account.web3auth.io/wallet/account";
      } else {
        options.sdkUrl = "https://auth.web3auth.io";
        options.dashboardUrl = "https://account.web3auth.io/wallet/account";
      }
    }
    if (options.useMpc && !options.sdkUrl) {
      if (Object.values(openlogin_utils_namespaceObject.TORUS_LEGACY_NETWORK).includes(options.network)) throw InitializationError.invalidParams("MPC is not supported on legacy networks, please use sapphire_devnet or sapphire_mainnet.");
      if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.DEVELOPMENT) {
        options.sdkUrl = "http://localhost:3000";
      } else if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.STAGING) {
        options.sdkUrl = "https://staging-mpc-auth.web3auth.io";
      } else if (options.buildEnv === openlogin_utils_namespaceObject.BUILD_ENV.TESTING) {
        options.sdkUrl = "https://develop-mpc-auth.web3auth.io";
      } else {
        options.sdkUrl = "https://mpc-auth.web3auth.io";
      }
    }
    if (!options.redirectUrl && typeof window !== "undefined") {
      options.redirectUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
    }
    if (!options.uxMode) options.uxMode = openlogin_utils_namespaceObject.UX_MODE.REDIRECT;
    if (typeof options.replaceUrlOnRedirect !== "boolean") options.replaceUrlOnRedirect = true;
    if (!options.originData) options.originData = {};
    if (!options.whiteLabel) options.whiteLabel = {};
    if (!options.loginConfig) options.loginConfig = {};
    if (!options.mfaSettings) options.mfaSettings = {};
    if (!options.storageServerUrl) options.storageServerUrl = constants_namespaceObject.SESSION_SERVER;
    if (!options.storageKey) options.storageKey = "local";
    if (!options.webauthnTransports) options.webauthnTransports = ["internal"];
    if (!options.sessionTime) options.sessionTime = 86400;
    this.options = options;
  }
  get privKey() {
    if (this.options.useMpc) return this.state.factorKey || "";
    return this.state.privKey ? this.state.privKey.padStart(64, "0") : "";
  }
  get coreKitKey() {
    return this.state.coreKitKey ? this.state.coreKitKey.padStart(64, "0") : "";
  }
  get ed25519PrivKey() {
    return this.state.ed25519PrivKey ? this.state.ed25519PrivKey.padStart(128, "0") : "";
  }
  get coreKitEd25519Key() {
    return this.state.coreKitEd25519PrivKey ? this.state.coreKitEd25519PrivKey.padStart(128, "0") : "";
  }
  get sessionId() {
    return this.state.sessionId || "";
  }
  get sessionNamespace() {
    return this.options.sessionNamespace || "";
  }
  get appState() {
    return this.state.userInfo.appState || this.dappState || "";
  }
  get baseUrl() {
    // testing and develop don't have versioning
    if (!this.addVersionInUrls) return `${this.options.sdkUrl}`;
    return `${this.options.sdkUrl}/v${version.split(".")[0]}`;
  }
  async init() {
    // get sessionNamespace from the redirect result.
    const params = getHashQueryParams(this.options.replaceUrlOnRedirect);
    if (params.sessionNamespace) this.options.sessionNamespace = params.sessionNamespace;
    const storageKey = this.options.sessionNamespace ? `${this._storageBaseKey}_${this.options.sessionNamespace}` : this._storageBaseKey;
    this.currentStorage = openlogin_utils_namespaceObject.BrowserStorage.getInstance(storageKey, this.options.storageKey);
    const sessionId = this.currentStorage.get("sessionId");
    this.sessionManager = new openlogin_session_manager_namespaceObject.OpenloginSessionManager({
      sessionServerBaseUrl: this.options.storageServerUrl,
      sessionNamespace: this.options.sessionNamespace,
      sessionTime: this.options.sessionTime,
      sessionId
    });
    if (this.options.network === openlogin_utils_namespaceObject.OPENLOGIN_NETWORK.TESTNET || this.options.network === openlogin_utils_namespaceObject.OPENLOGIN_NETWORK.SAPPHIRE_DEVNET) {
      // using console log because it shouldn't be affected by loglevel config
      // eslint-disable-next-line no-console
      console.log(`%c WARNING! You are on ${this.options.network}. Please set network: 'mainnet' or 'sapphire_mainnet' in production`, "color: #FF0000");
    }
    if (this.options.buildEnv !== openlogin_utils_namespaceObject.BUILD_ENV.PRODUCTION) {
      // using console log because it shouldn't be affected by loglevel config
      // eslint-disable-next-line no-console
      console.log(`%c WARNING! You are using build env ${this.options.buildEnv}. Please set buildEnv: 'production' in production`, "color: #FF0000");
    }
    if (params.error) {
      this.dappState = params.state;
      throw LoginError.loginFailed(params.error);
    }
    if (params.sessionId) {
      this.currentStorage.set("sessionId", params.sessionId);
      this.sessionManager.sessionId = params.sessionId;
    }
    if (this.sessionManager.sessionId) {
      const data = await this._authorizeSession();
      // Fill state with correct info from session
      // If session is invalid all the data is unset here.
      this.updateState(data);
      if (Object.keys(data).length === 0) {
        // If session is invalid, unset the sessionId from localStorage.
        this.currentStorage.set("sessionId", "");
      }
    }
  }
  async login(params) {
    if (!params.loginProvider) throw LoginError.invalidLoginParams(`loginProvider is required`);

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const loginParams = objectSpread2_default()(objectSpread2_default()({
      loginProvider: params.loginProvider
    }, defaultParams), params);
    const dataObject = {
      actionType: openlogin_utils_namespaceObject.OPENLOGIN_ACTIONS.LOGIN,
      options: this.options,
      params: loginParams
    };
    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject, getTimeout(params.loginProvider));
    if (this.options.uxMode === openlogin_utils_namespaceObject.UX_MODE.REDIRECT) return null;
    if (result.error) {
      this.dappState = result.state;
      throw LoginError.loginFailed(result.error);
    }
    this.sessionManager.sessionId = result.sessionId;
    this.options.sessionNamespace = result.sessionNamespace;
    this.currentStorage.set("sessionId", result.sessionId);
    await this.rehydrateSession();
    return {
      privKey: this.privKey
    };
  }
  async logout() {
    if (!this.sessionManager.sessionId) throw LoginError.userNotLoggedIn();
    await this.sessionManager.invalidateSession();
    this.updateState({
      privKey: "",
      coreKitKey: "",
      coreKitEd25519PrivKey: "",
      ed25519PrivKey: "",
      walletKey: "",
      oAuthPrivateKey: "",
      tKey: "",
      metadataNonce: "",
      keyMode: undefined,
      userInfo: {
        name: "",
        profileImage: "",
        dappShare: "",
        idToken: "",
        oAuthIdToken: "",
        oAuthAccessToken: "",
        appState: "",
        email: "",
        verifier: "",
        verifierId: "",
        aggregateVerifier: "",
        typeOfLogin: "",
        isMfaEnabled: false
      },
      authToken: "",
      sessionId: "",
      factorKey: "",
      signatures: [],
      tssShareIndex: -1,
      tssPubKey: "",
      tssShare: "",
      tssNonce: -1
    });
    this.currentStorage.set("sessionId", "");
  }
  async enableMFA(params) {
    var _this$state$userInfo;
    if (!this.sessionId) throw LoginError.userNotLoggedIn();
    if (this.state.userInfo.isMfaEnabled) throw LoginError.mfaAlreadyEnabled();
    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: openlogin_utils_namespaceObject.OPENLOGIN_ACTIONS.ENABLE_MFA,
      options: this.options,
      params: objectSpread2_default()(objectSpread2_default()(objectSpread2_default()({}, defaultParams), params), {}, {
        loginProvider: this.state.userInfo.typeOfLogin,
        extraLoginOptions: {
          login_hint: this.state.userInfo.verifierId
        },
        mfaLevel: "mandatory"
      }),
      sessionId: this.sessionId
    };
    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject, getTimeout(dataObject.params.loginProvider));
    if (this.options.uxMode === openlogin_utils_namespaceObject.UX_MODE.REDIRECT) return null;
    if (result.error) {
      this.dappState = result.state;
      throw LoginError.loginFailed(result.error);
    }
    this.sessionManager.sessionId = result.sessionId;
    this.options.sessionNamespace = result.sessionNamespace;
    this.currentStorage.set("sessionId", result.sessionId);
    await this.rehydrateSession();
    return Boolean((_this$state$userInfo = this.state.userInfo) === null || _this$state$userInfo === void 0 ? void 0 : _this$state$userInfo.isMfaEnabled);
  }
  async manageMFA(params) {
    if (!this.sessionId) throw LoginError.userNotLoggedIn();
    if (!this.state.userInfo.isMfaEnabled) throw LoginError.mfaNotEnabled();

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.dashboardUrl,
      dappUrl: `${window.location.origin}${window.location.pathname}`
    };
    const loginId = openlogin_session_manager_namespaceObject.OpenloginSessionManager.generateRandomSessionKey();
    const dataObject = {
      actionType: openlogin_utils_namespaceObject.OPENLOGIN_ACTIONS.MANAGE_MFA,
      options: this.options,
      params: objectSpread2_default()(objectSpread2_default()(objectSpread2_default()({}, defaultParams), params), {}, {
        loginProvider: this.state.userInfo.typeOfLogin,
        extraLoginOptions: {
          login_hint: this.state.userInfo.verifierId
        },
        appState: (0,openlogin_utils_namespaceObject.jsonToBase64)({
          loginId
        })
      }),
      sessionId: this.sessionId
    };
    this.createLoginSession(loginId, dataObject, dataObject.options.sessionTime, true);
    const configParams = {
      loginId,
      sessionNamespace: this.options.sessionNamespace,
      storageServerUrl: this.options.storageServerUrl
    };
    const loginUrl = constructURL({
      baseURL: `${this.baseUrl}/start`,
      hash: {
        b64Params: (0,openlogin_utils_namespaceObject.jsonToBase64)(configParams)
      }
    });
    window.open(loginUrl, "_blank");
  }
  async changeSocialFactor(params) {
    if (!this.sessionId) throw LoginError.userNotLoggedIn();

    // in case of redirect mode, redirect url will be dapp specified
    // in case of popup mode, redirect url will be sdk specified
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: openlogin_utils_namespaceObject.OPENLOGIN_ACTIONS.MODIFY_SOCIAL_FACTOR,
      options: this.options,
      params: objectSpread2_default()(objectSpread2_default()({}, defaultParams), params),
      sessionId: this.sessionId
    };
    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject);
    if (this.options.uxMode === openlogin_utils_namespaceObject.UX_MODE.REDIRECT) return undefined;
    if (result.error) return false;
    return true;
  }
  getUserInfo() {
    if (!this.sessionManager.sessionId) {
      throw LoginError.userNotLoggedIn();
    }
    return this.state.userInfo;
  }
  async createLoginSession(loginId, data) {
    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 600;
    let skipAwait = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (!this.sessionManager) throw InitializationError.notInitialized();
    const loginSessionMgr = new openlogin_session_manager_namespaceObject.OpenloginSessionManager({
      sessionServerBaseUrl: data.options.storageServerUrl,
      sessionNamespace: data.options.sessionNamespace,
      sessionTime: timeout,
      // each login key must be used with 10 mins (might be used at the end of popup redirect)
      sessionId: loginId
    });
    const promise = loginSessionMgr.createSession(JSON.parse(JSON.stringify(data)));
    if (data.options.uxMode === openlogin_utils_namespaceObject.UX_MODE.REDIRECT && !skipAwait) {
      await promise;
    }
  }
  async _authorizeSession() {
    try {
      if (!this.sessionManager.sessionId) return {};
      const result = await this.sessionManager.authorizeSession();
      return result;
    } catch (err) {
      loglevel.error("authorization failed", err);
      return {};
    }
  }
  updateState(data) {
    this.state = objectSpread2_default()(objectSpread2_default()({}, this.state), data);
  }
  async rehydrateSession() {
    const result = await this._authorizeSession();
    this.updateState(result);
  }
  async openloginHandler(url, dataObject) {
    let popupTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000 * 10;
    const loginId = openlogin_session_manager_namespaceObject.OpenloginSessionManager.generateRandomSessionKey();
    await this.createLoginSession(loginId, dataObject);
    const configParams = {
      loginId,
      sessionNamespace: this.options.sessionNamespace,
      storageServerUrl: this.options.storageServerUrl
    };
    if (this.options.uxMode === openlogin_utils_namespaceObject.UX_MODE.REDIRECT) {
      const loginUrl = constructURL({
        baseURL: url,
        hash: {
          b64Params: (0,openlogin_utils_namespaceObject.jsonToBase64)(configParams)
        }
      });
      window.location.href = loginUrl;
      return undefined;
    }
    const loginUrl = constructURL({
      baseURL: url,
      hash: {
        b64Params: (0,openlogin_utils_namespaceObject.jsonToBase64)(configParams)
      }
    });
    const currentWindow = new src_PopupHandler({
      url: loginUrl,
      timeout: popupTimeout
    });
    return new Promise((resolve, reject) => {
      currentWindow.on("close", () => {
        reject(LoginError.popupClosed());
      });
      currentWindow.listenOnChannel(loginId).then(resolve).catch(reject);
      try {
        currentWindow.open();
      } catch (error) {
        reject(error);
      }
    });
  }
}
/* harmony default export */ const src_OpenLogin = (OpenLogin);
;// CONCATENATED MODULE: ./src/index.ts




module.exports = __webpack_exports__;
/******/ })()
;