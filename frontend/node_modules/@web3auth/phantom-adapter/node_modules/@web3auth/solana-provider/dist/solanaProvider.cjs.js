/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  PhantomInjectedProvider: () => (/* reexport */ PhantomInjectedProvider),
  SolanaPrivateKeyProvider: () => (/* reexport */ SolanaPrivateKeyProvider),
  SolanaWallet: () => (/* reexport */ SolanaWallet),
  SolflareInjectedProvider: () => (/* reexport */ SolflareInjectedProvider),
  TorusInjectedProvider: () => (/* reexport */ TorusInjectedProvider),
  WalletStandardProvider: () => (/* reexport */ WalletStandardProvider)
});

;// CONCATENATED MODULE: external "@toruslabs/openlogin-jrpc"
const openlogin_jrpc_namespaceObject = require("@toruslabs/openlogin-jrpc");
;// CONCATENATED MODULE: external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// CONCATENATED MODULE: external "@web3auth/base-provider"
const base_provider_namespaceObject = require("@web3auth/base-provider");
;// CONCATENATED MODULE: external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
;// CONCATENATED MODULE: ./src/rpc/JrpcClient.ts


function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "solana_chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "solana_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createConfigMiddleware(providerConfig) {
  const {
    chainId
  } = providerConfig;
  return (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);
}
function createJsonRpcClient(providerConfig) {
  const {
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = (0,base_controllers_namespaceObject.createFetchMiddleware)({
    rpcTarget
  });
  const networkMiddleware = (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([createConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
;// CONCATENATED MODULE: ./src/rpc/solanaRpcMiddlewares.ts

function createGetAccountsMiddleware({
  getAccounts
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "getAccounts") return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    // This calls from the prefs controller
    const accounts = await getAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createRequestAccountsMiddleware({
  requestAccounts
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "requestAccounts") return next();
    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    // This calls the UI login function
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createGenericJRPCMiddleware(targetMethod, handler) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== targetMethod) return next();
    if (!handler) throw new Error(`WalletMiddleware - ${targetMethod} not provided`);
    const result = await handler(request);
    response.result = result;
    return undefined;
  });
}
function createSolanaMiddleware(providerHandlers) {
  const {
    getAccounts,
    requestAccounts,
    signTransaction,
    signAndSendTransaction,
    signAllTransactions,
    signMessage,
    getPrivateKey,
    getSecretKey
  } = providerHandlers;
  return (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), createGenericJRPCMiddleware("signTransaction", signTransaction), createGenericJRPCMiddleware("signAndSendTransaction", signAndSendTransaction), createGenericJRPCMiddleware("signAllTransactions", signAllTransactions), createGenericJRPCMiddleware("signMessage", signMessage), createGenericJRPCMiddleware("solanaPrivateKey", getPrivateKey), createGenericJRPCMiddleware("private_key", getPrivateKey), createGenericJRPCMiddleware("solanaSecretKey", getSecretKey)]);
}
function createChainSwitchMiddleware({
  addNewChainConfig,
  switchSolanaChain
}) {
  return (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([createGenericJRPCMiddleware("addSolanaChain", addNewChainConfig), createGenericJRPCMiddleware("switchSolanaChain", switchSolanaChain)]);
}
function createAccountMiddleware({
  updatePrivatekey
}) {
  return (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([createGenericJRPCMiddleware("updateAccount", updatePrivatekey)]);
}
;// CONCATENATED MODULE: ./src/providers/injectedProviders/base/baseInjectedProvider.ts





class BaseInjectedProvider extends base_provider_namespaceObject.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
  }
  async switchChain(_) {
    throw base_namespaceObject.WalletLoginError.unsupportedOperation("Chain switching is not supported by this adapter");
  }
  async setupProvider(injectedProvider) {
    const engine = new openlogin_jrpc_namespaceObject.JRPCEngine();
    const providerHandlers = this.getProviderHandlers(injectedProvider);
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    engine.push(solanaMiddleware);
    const configMiddleware = createConfigMiddleware(this.config.chainConfig);
    engine.push(configMiddleware);
    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);
    if (injectedProviderProxy) {
      engine.push(injectedProviderProxy);
    }
    const provider = (0,openlogin_jrpc_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async lookupNetwork() {
    const {
      chainConfig
    } = this.config;
    this.update({
      chainId: chainConfig.chainId
    });
    return chainConfig.chainId || "";
  }
  getInjectedProviderProxy(_) {
    return undefined;
  }
}
;// CONCATENATED MODULE: external "bs58"
const external_bs58_namespaceObject = require("bs58");
var external_bs58_default = /*#__PURE__*/__webpack_require__.n(external_bs58_namespaceObject);
;// CONCATENATED MODULE: ./src/providers/injectedProviders/base/providerHandlers.ts


const getBaseProviderHandlers = injectedProvider => {
  const providerHandlers = {
    requestAccounts: async () => {
      return injectedProvider.publicKey ? [external_bs58_default().encode(injectedProvider.publicKey.toBytes())] : [];
    },
    getAccounts: async () => injectedProvider.publicKey ? [external_bs58_default().encode(injectedProvider.publicKey.toBytes())] : [],
    getPrivateKey: async () => {
      throw openlogin_jrpc_namespaceObject.rpcErrors.methodNotSupported();
    },
    getSecretKey: async () => {
      throw openlogin_jrpc_namespaceObject.rpcErrors.methodNotSupported();
    },
    signTransaction: async req => {
      const transaction = await injectedProvider.signTransaction(req.params.message);
      return transaction;
    },
    signMessage: async req => {
      const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);
      return sigData.signature;
    },
    signAllTransactions: async req => {
      var _req$params, _req$params2;
      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const transaction = await injectedProvider.signAllTransactions(req.params.message);
      return transaction;
    },
    signAndSendTransaction: async req => {
      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);
      return {
        signature: txRes.signature
      };
    }
  };
  return providerHandlers;
};
;// CONCATENATED MODULE: ./src/providers/injectedProviders/injectedProviderProxy.ts

function createInjectedProviderProxyMiddleware(provider) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (req, res, _next) => {
    const result = await provider.request(req);
    res.result = result;
  });
}
;// CONCATENATED MODULE: ./src/providers/injectedProviders/phantom/phantomInjectedProvider.ts



class PhantomInjectedProvider extends BaseInjectedProvider {
  getProviderHandlers(injectedProvider) {
    return getBaseProviderHandlers(injectedProvider);
  }
  getInjectedProviderProxy(injectedProvider) {
    return createInjectedProviderProxyMiddleware(injectedProvider);
  }
}
;// CONCATENATED MODULE: external "@solana/web3.js"
const web3_js_namespaceObject = require("@solana/web3.js");
;// CONCATENATED MODULE: ./src/providers/injectedProviders/solflare/providerHandlers.ts



const getSolflareHandlers = (injectedProvider, getProviderEngineProxy) => {
  const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider);
  solflareProviderHandlers.signAndSendTransaction = async req => {
    const provider = getProviderEngineProxy();
    if (!provider) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const transaction = await injectedProvider.signTransaction(req.params.message);
    const chainConfig = await provider.request({
      method: "solana_provider_config"
    });
    const conn = new web3_js_namespaceObject.Connection(chainConfig.rpcTarget);
    const res = await conn.sendRawTransaction(transaction.serialize());
    return {
      signature: res
    };
  };
  solflareProviderHandlers.signMessage = async req => {
    const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);
    return sigData;
  };
  return solflareProviderHandlers;
};
;// CONCATENATED MODULE: ./src/providers/injectedProviders/solflare/solflareInjectedProvider.ts


class SolflareInjectedProvider extends BaseInjectedProvider {
  getProviderHandlers(injectedProvider) {
    return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));
  }
}
;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: ./src/providers/injectedProviders/torus/providerHandlers.ts

const getTorusHandlers = injectedProvider => {
  const providerHandlers = {
    requestAccounts: async () => {
      const accounts = await injectedProvider.request({
        method: "solana_requestAccounts",
        params: {}
      });
      return accounts;
    },
    getAccounts: async () => {
      const accounts = await injectedProvider.request({
        method: "solana_requestAccounts",
        params: {}
      });
      return accounts;
    },
    getPrivateKey: async () => {
      throw openlogin_jrpc_namespaceObject.rpcErrors.methodNotSupported();
    },
    getSecretKey: async () => {
      throw openlogin_jrpc_namespaceObject.rpcErrors.methodNotSupported();
    },
    signMessage: async req => {
      var _req$params;
      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const message = await injectedProvider.signMessage(req.params.message);
      return message;
    },
    signTransaction: async req => {
      var _req$params2;
      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const txMessage = req.params.message;
      const response = await injectedProvider.signTransaction(txMessage);
      return response;
    },
    signAndSendTransaction: async req => {
      var _req$params3;
      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const txMessage = req.params.message;
      const response = await injectedProvider.sendTransaction(txMessage);
      return {
        signature: response
      };
    },
    signAllTransactions: async req => {
      var _req$params4, _req$params5;
      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const transactions = req.params.message;
      const response = await injectedProvider.signAllTransactions(transactions);
      return response;
    }
  };
  return providerHandlers;
};
;// CONCATENATED MODULE: ./src/providers/injectedProviders/torus/torusInjectedProvider.ts








class TorusInjectedProvider extends base_provider_namespaceObject.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "PROVIDER_CHAIN_NAMESPACE", "solana");
  }
  async switchChain(params) {
    // overrides the base provider implementation
    await this.provider.request({
      method: "switchSolanaChain",
      params: [{
        chainId: params.chainId
      }]
    });
  }
  async addChain(chainConfig) {
    super.addChain(chainConfig);
    await this.provider.request({
      method: "addNewChainConfig",
      params: [{
        chainId: chainConfig.chainId,
        chainName: chainConfig.displayName,
        rpcUrls: [chainConfig.rpcTarget],
        blockExplorerUrls: [chainConfig.blockExplorerUrl],
        iconUrls: [chainConfig.logo],
        nativeCurrency: {
          name: chainConfig.tickerName,
          symbol: chainConfig.ticker,
          decimals: chainConfig.decimals || 18
        }
      }]
    });
  }
  async setupProvider(injectedProvider) {
    this.handleInjectedProviderUpdate(injectedProvider);
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base_namespaceObject.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    await this.setupEngine(injectedProvider);
  }
  async lookupNetwork() {
    if (!this.provider) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
      message: "Torus solana provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    const connectedChainId = await this.provider.request({
      method: "solana_chainId"
    });
    const connectedHexChainId = (0,base_namespaceObject.isHexStrict)(connectedChainId.toString()) ? connectedChainId : `0x${parseInt(connectedChainId, 10).toString(16)}`;
    if (chainId !== connectedHexChainId) throw base_namespaceObject.WalletInitializationError.rpcConnectionError(`Invalid network, net_version is: ${connectedHexChainId}, expected: ${chainId}`);
    this.update({
      chainId: connectedHexChainId
    });
    this.emit("connect", {
      chainId: this.state.chainId
    });
    this.emit("chainChanged", this.state.chainId);
    return this.state.chainId;
  }
  async setupEngine(injectedProvider) {
    const providerHandlers = getTorusHandlers(injectedProvider);
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);
    const engine = new openlogin_jrpc_namespaceObject.JRPCEngine();
    engine.push(solanaMiddleware);
    engine.push(injectedProviderProxy);
    const provider = (0,openlogin_jrpc_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async handleInjectedProviderUpdate(injectedProvider) {
    injectedProvider.on("accountsChanged", async accounts => {
      this.emit("accountsChanged", accounts);
    });
    injectedProvider.on("chainChanged", async chainId => {
      const connectedHexChainId = (0,base_namespaceObject.isHexStrict)(chainId) ? chainId : `0x${parseInt(chainId, 10).toString(16)}`;
      // Check if chainId changed and trigger event
      this.configure({
        chainConfig: objectSpread2_default()(objectSpread2_default()({}, this.config.chainConfig), {}, {
          chainId: connectedHexChainId
        })
      });
      await this.setupProvider(injectedProvider);
    });
  }
}
;// CONCATENATED MODULE: ./src/providers/injectedProviders/walletStandardProvider.ts


class WalletStandardProvider extends BaseInjectedProvider {
  getProviderHandlers(injectedProvider) {
    return getBaseProviderHandlers(injectedProvider);
  }
}
;// CONCATENATED MODULE: ./src/providers/injectedProviders/index.ts





;// CONCATENATED MODULE: external "@toruslabs/openlogin-ed25519"
const openlogin_ed25519_namespaceObject = require("@toruslabs/openlogin-ed25519");
;// CONCATENATED MODULE: external "@toruslabs/tweetnacl-js"
const tweetnacl_js_namespaceObject = require("@toruslabs/tweetnacl-js");
var tweetnacl_js_default = /*#__PURE__*/__webpack_require__.n(tweetnacl_js_namespaceObject);
;// CONCATENATED MODULE: ./src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts





async function getProviderHandlers({
  privKey,
  getProviderEngineProxy
}) {
  const keyPairGenerator = () => {
    return web3_js_namespaceObject.Keypair.fromSecretKey(Buffer.from(privKey, "hex"));
  };
  if (typeof privKey !== "string") throw base_namespaceObject.WalletInitializationError.invalidParams("privKey must be a string");
  const keyPair = keyPairGenerator();
  const providerHandlers = {
    requestAccounts: async () => {
      return [keyPair.publicKey.toBase58()];
    },
    getAccounts: async () => [keyPair.publicKey.toBase58()],
    getPrivateKey: async () => privKey,
    getSecretKey: async () => external_bs58_default().encode(keyPair.secretKey),
    signTransaction: async req => {
      var _req$params;
      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const transaction = req.params.message;
      if (transaction.version !== undefined || transaction instanceof web3_js_namespaceObject.VersionedTransaction) {
        transaction.sign([keyPair]);
      } else {
        transaction.partialSign(keyPair);
      }
      return transaction;
    },
    signMessage: async req => {
      var _req$params2;
      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const signedMsg = tweetnacl_js_default().sign.detached(req.params.message, keyPair.secretKey);
      return signedMsg;
    },
    signAndSendTransaction: async req => {
      var _req$params3;
      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const _providerEngineProxy = getProviderEngineProxy();
      if (!_providerEngineProxy) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const transaction = req.params.message;
      if (transaction.version !== undefined || transaction instanceof web3_js_namespaceObject.VersionedTransaction) {
        transaction.sign([keyPair]);
      } else {
        transaction.partialSign(keyPair);
      }
      const sig = await _providerEngineProxy.request({
        method: "sendTransaction",
        params: [Buffer.from(transaction.serialize()).toString("base64"), {
          encoding: "base64",
          preflightCommitment: "confirmed"
        }]
      });
      return {
        signature: sig
      };
    },
    signAllTransactions: async req => {
      var _req$params4, _req$params5, _req$params6;
      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("message");
      }
      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;
      for (const tx of txns || []) {
        const transaction = tx;
        if (transaction.version !== undefined || transaction instanceof web3_js_namespaceObject.VersionedTransaction) {
          transaction.sign([keyPair]);
        } else {
          transaction.partialSign(keyPair);
        }
      }
      return txns;
    }
  };
  return providerHandlers;
}
;// CONCATENATED MODULE: ./src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts

var _SolanaPrivateKeyProvider;







class SolanaPrivateKeyProvider extends base_provider_namespaceObject.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "PROVIDER_CHAIN_NAMESPACE", base_namespaceObject.CHAIN_NAMESPACES.SOLANA);
  }
  async enable() {
    if (!this.state.privateKey) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  getEd25519Key(privateKey) {
    return (0,openlogin_ed25519_namespaceObject.getED25519Key)(privateKey).sk.toString("hex").padStart(128, "0");
  }
  async setupProvider(privKey) {
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base_namespaceObject.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const providerHandlers = await getProviderHandlers({
      privKey,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    const engine = new openlogin_jrpc_namespaceObject.JRPCEngine();
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(this.getChainSwitchMiddleware());
    engine.push(this.getAccountMiddleware());
    engine.push(solanaMiddleware);
    engine.push(networkMiddleware);
    const provider = (0,openlogin_jrpc_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async updateAccount(params) {
    if (!this._providerEngineProxy) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const existingKey = await this._providerEngineProxy.request({
      method: "solanaPrivateKey"
    });
    if (existingKey !== params.privateKey) {
      await this.setupProvider(params.privateKey);
      this.emit("accountsChanged", {
        accounts: await this._providerEngineProxy.request({
          method: "requestAccounts"
        })
      });
    }
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const privKey = await this._providerEngineProxy.request({
      method: "solanaPrivateKey"
    });
    await this.setupProvider(privKey);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw openlogin_jrpc_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const health = await this._providerEngineProxy.request({
      method: "getHealth",
      params: []
    });
    const {
      chainConfig
    } = this.config;
    if (health !== "ok") throw base_namespaceObject.WalletInitializationError.rpcConnectionError(`Failed to lookup network for following rpc target: ${chainConfig.rpcTarget}`);
    this.update({
      chainId: chainConfig.chainId
    });
    if (this.state.chainId !== chainConfig.chainId) {
      this.emit("chainChanged", this.state.chainId);
      this.emit("connect", {
        chainId: this.state.chainId
      });
    }
    return this.state.chainId;
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addNewChainConfig: async req => {
        if (!req.params) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing request params");
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency,
          iconUrls
        } = req.params;
        if (!chainId) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing chainId in chainParams");
        if (!rpcUrls || rpcUrls.length === 0) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing rpcUrls in chainParams");
        if (!nativeCurrency) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing nativeCurrency in chainParams");
        this.addChain({
          chainNamespace: base_namespaceObject.CHAIN_NAMESPACES.SOLANA,
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "SOL",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Solana",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorerUrl: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || "",
          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 9,
          logo: (iconUrls === null || iconUrls === void 0 ? void 0 : iconUrls[0]) || "https://images.toruswallet.io/sol.svg"
        });
      },
      switchSolanaChain: async req => {
        if (!req.params) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing request params");
        if (!req.params.chainId) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing chainId");
        await this.switchChain(req.params);
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
  getAccountMiddleware() {
    const accountHandlers = {
      updatePrivatekey: async req => {
        if (!req.params) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing request params");
        if (!req.params.privateKey) throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Missing privateKey");
        const {
          privateKey
        } = req.params;
        await this.updateAccount({
          privateKey
        });
      }
    };
    return createAccountMiddleware(accountHandlers);
  }
}
_SolanaPrivateKeyProvider = SolanaPrivateKeyProvider;
defineProperty_default()(SolanaPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _SolanaPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});
;// CONCATENATED MODULE: ./src/providers/privateKeyProvider/index.ts

;// CONCATENATED MODULE: ./src/providers/index.ts


;// CONCATENATED MODULE: ./src/solanaWallet.ts

class SolanaWallet {
  constructor(provider) {
    defineProperty_default()(this, "provider", void 0);
    this.provider = provider;
  }
  async requestAccounts() {
    const accounts = await this.provider.request({
      method: "requestAccounts"
    });
    return accounts;
  }
  async signAndSendTransaction(transaction) {
    const {
      signature
    } = await this.provider.request({
      method: "signAndSendTransaction",
      params: {
        message: transaction
      }
    });
    return {
      signature
    };
  }
  async signTransaction(transaction) {
    const signedTransaction = await this.provider.request({
      method: "signTransaction",
      params: {
        message: transaction
      }
    });
    return signedTransaction;
  }
  async signAllTransactions(transactions) {
    const signedTransactions = await this.provider.request({
      method: "signAllTransactions",
      params: {
        message: transactions
      }
    });
    return signedTransactions;
  }
  async signMessage(data) {
    const response = await this.provider.request({
      method: "signMessage",
      params: {
        message: data
      }
    });
    return response;
  }
  async request(args) {
    const result = await this.provider.request(args);
    return result;
  }
}
;// CONCATENATED MODULE: ./src/index.ts



module.exports = __webpack_exports__;
/******/ })()
;