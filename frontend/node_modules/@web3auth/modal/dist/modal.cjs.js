/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 149:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gu: () => (/* binding */ defaultSolanaDappModalConfig),
/* harmony export */   KT: () => (/* binding */ defaultSolanaWalletModalConfig),
/* harmony export */   Lu: () => (/* binding */ defaultOtherModalConfig),
/* harmony export */   e4: () => (/* binding */ walletRegistryUrl),
/* harmony export */   eA: () => (/* binding */ defaultEvmWalletModalConfig),
/* harmony export */   g2: () => (/* binding */ defaultEvmDappModalConfig)
/* harmony export */ });
/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(377);
/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_web3auth_base__WEBPACK_IMPORTED_MODULE_0__);

const defaultSolanaDappModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.CHAIN_NAMESPACES.SOLANA,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ADAPTERS.TORUS_SOLANA]: {
      label: "Torus Wallet",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ADAPTERS.AUTH]: {
      label: "Auth",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultEvmDappModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.CHAIN_NAMESPACES.EIP155,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.EVM_ADAPTERS.TORUS_EVM]: {
      label: "Torus Wallet",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.EVM_ADAPTERS.AUTH]: {
      label: "Auth",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.EVM_ADAPTERS.WALLET_CONNECT_V2]: {
      label: "Wallet Connect",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultSolanaWalletModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.CHAIN_NAMESPACES.SOLANA,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ADAPTERS.AUTH]: {
      label: "Auth",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultEvmWalletModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.CHAIN_NAMESPACES.EIP155,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.EVM_ADAPTERS.AUTH]: {
      label: "Auth",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const defaultOtherModalConfig = {
  chainNamespace: _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.CHAIN_NAMESPACES.OTHER,
  adapters: {
    [_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.EVM_ADAPTERS.AUTH]: {
      label: "Auth",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
const walletRegistryUrl = "https://assets.web3auth.io/v1/wallet-registry.json";

/***/ }),

/***/ 624:
/***/ (() => {



/***/ }),

/***/ 430:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  y: () => (/* binding */ Web3Auth)
});

;// external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// external "@web3auth/auth-adapter"
const auth_adapter_namespaceObject = require("@web3auth/auth-adapter");
// EXTERNAL MODULE: external "@web3auth/base"
var base_ = __webpack_require__(377);
;// external "@web3auth/base-provider"
const base_provider_namespaceObject = require("@web3auth/base-provider");
;// external "@web3auth/no-modal"
const no_modal_namespaceObject = require("@web3auth/no-modal");
;// external "@web3auth/ui"
const ui_namespaceObject = require("@web3auth/ui");
;// external "deepmerge"
const external_deepmerge_namespaceObject = require("deepmerge");
var external_deepmerge_default = /*#__PURE__*/__webpack_require__.n(external_deepmerge_namespaceObject);
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(149);
;// ./src/modalManager.ts









class Web3Auth extends no_modal_namespaceObject.Web3AuthNoModal {
  constructor(options) {
    super(options);
    defineProperty_default()(this, "loginModal", void 0);
    defineProperty_default()(this, "options", void 0);
    defineProperty_default()(this, "modalConfig", (0,base_.cloneDeep)(config/* defaultOtherModalConfig */.Lu));
    this.options = objectSpread2_default()({}, options);
    if (!this.options.uiConfig) this.options.uiConfig = {};
    if (!this.coreOptions.privateKeyProvider) throw base_.WalletInitializationError.invalidParams("privateKeyProvider is required");
  }
  setModalConfig(modalConfig) {
    super.checkInitRequirements();
    this.modalConfig = modalConfig;
  }
  async initModal(params) {
    var _params;
    super.checkInitRequirements();
    let projectConfig;
    try {
      var _this$options$account;
      projectConfig = await (0,base_.fetchProjectConfig)(this.options.clientId, this.options.web3AuthNetwork, (_this$options$account = this.options.accountAbstractionProvider) === null || _this$options$account === void 0 ? void 0 : _this$options$account.config.smartAccountInit.name);
    } catch (e) {
      base_.log.error("Failed to fetch project configurations", e);
      throw base_.WalletInitializationError.notReady("failed to fetch project configurations", e);
    }
    const {
      whitelabel
    } = projectConfig;
    this.options.uiConfig = external_deepmerge_default()((0,base_.cloneDeep)(whitelabel || {}), this.options.uiConfig || {});
    if (!this.options.uiConfig.defaultLanguage) this.options.uiConfig.defaultLanguage = (0,ui_namespaceObject.getUserLanguage)(this.options.uiConfig.defaultLanguage);
    if (!this.options.uiConfig.mode) this.options.uiConfig.mode = "light";
    let walletRegistry = {
      others: {},
      default: {}
    };
    if (!((_params = params) !== null && _params !== void 0 && _params.hideWalletDiscovery)) {
      try {
        walletRegistry = await (0,base_.fetchWalletRegistry)(config/* walletRegistryUrl */.e4);
      } catch (e) {
        base_.log.error("Failed to fetch wallet registry", e);
      }
    }
    this.loginModal = new ui_namespaceObject.LoginModal(objectSpread2_default()(objectSpread2_default()({}, this.options.uiConfig), {}, {
      adapterListener: this,
      chainNamespace: this.options.chainConfig.chainNamespace,
      walletRegistry
    }));
    this.subscribeToLoginModalEvents();
    const {
      sms_otp_enabled: smsOtpEnabled,
      whitelist,
      key_export_enabled: keyExportEnabled
    } = projectConfig;
    if (smsOtpEnabled !== undefined) {
      var _params2, _params$modalConfig$W;
      const adapterConfig = {
        [base_.WALLET_ADAPTERS.AUTH]: {
          label: base_.WALLET_ADAPTERS.AUTH,
          loginMethods: {
            [auth_adapter_namespaceObject.LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
              name: auth_adapter_namespaceObject.LOGIN_PROVIDER.SMS_PASSWORDLESS,
              showOnModal: smsOtpEnabled,
              showOnDesktop: smsOtpEnabled,
              showOnMobile: smsOtpEnabled
            }
          }
        }
      };
      if (!((_params2 = params) !== null && _params2 !== void 0 && _params2.modalConfig)) params = {
        modalConfig: {}
      };
      const localSmsOtpEnabled = (_params$modalConfig$W = params.modalConfig[base_.WALLET_ADAPTERS.AUTH]) === null || _params$modalConfig$W === void 0 || (_params$modalConfig$W = _params$modalConfig$W.loginMethods) === null || _params$modalConfig$W === void 0 || (_params$modalConfig$W = _params$modalConfig$W[auth_adapter_namespaceObject.LOGIN_PROVIDER.SMS_PASSWORDLESS]) === null || _params$modalConfig$W === void 0 ? void 0 : _params$modalConfig$W.showOnModal;
      if (localSmsOtpEnabled === true && smsOtpEnabled === false) {
        throw base_.WalletInitializationError.invalidParams("must enable sms otp on dashboard in order to utilise it");
      }
      params.modalConfig = external_deepmerge_default()(adapterConfig, (0,base_.cloneDeep)(params.modalConfig));
    }
    await this.loginModal.initModal();
    const providedChainConfig = this.options.chainConfig;
    // merge default adapters with the custom configured adapters.
    const allAdapters = [...new Set([...Object.keys(this.modalConfig.adapters || {}), ...Object.keys(this.walletAdapters)])];
    const adapterConfigurationPromises = allAdapters.map(async adapterName => {
      var _this$modalConfig$ada, _params3, _this$modalConfig$ada2, _this$modalConfig$ada3;
      // start with the default config of adapter.
      let adapterConfig = ((_this$modalConfig$ada = this.modalConfig.adapters) === null || _this$modalConfig$ada === void 0 ? void 0 : _this$modalConfig$ada[adapterName]) || {
        label: base_.ADAPTER_NAMES[adapterName] || adapterName.split("-").map(ui_namespaceObject.capitalizeFirstLetter).join(" "),
        showOnModal: true,
        showOnMobile: true,
        showOnDesktop: true
      };

      // override the default config of adapter if some config is being provided by the user.
      if ((_params3 = params) !== null && _params3 !== void 0 && (_params3 = _params3.modalConfig) !== null && _params3 !== void 0 && _params3[adapterName]) {
        adapterConfig = objectSpread2_default()(objectSpread2_default()({}, adapterConfig), params.modalConfig[adapterName]);
      }
      this.modalConfig.adapters[adapterName] = adapterConfig;

      // check if adapter is configured/added by user and exist in walletAdapters map.
      const adapter = this.walletAdapters[adapterName];
      base_.log.debug("adapter config", adapterName, (_this$modalConfig$ada2 = this.modalConfig.adapters) === null || _this$modalConfig$ada2 === void 0 ? void 0 : _this$modalConfig$ada2[adapterName].showOnModal, adapter);

      // if adapter is not custom configured then check if it is available in default adapters.
      // and if adapter is not hidden by user
      if (!adapter && (_this$modalConfig$ada3 = this.modalConfig.adapters) !== null && _this$modalConfig$ada3 !== void 0 && _this$modalConfig$ada3[adapterName].showOnModal) {
        // Adapters to be shown on modal should be pre-configured.
        if (adapterName === base_.WALLET_ADAPTERS.AUTH) {
          var _this$coreOptions$cha;
          const defaultOptions = (0,auth_adapter_namespaceObject.getAuthDefaultOptions)();
          const {
            clientId,
            useCoreKitKey,
            chainConfig,
            web3AuthNetwork,
            sessionTime,
            privateKeyProvider
          } = this.coreOptions;
          const finalChainConfig = objectSpread2_default()(objectSpread2_default()({}, (0,base_.getChainConfig)(providedChainConfig.chainNamespace, (_this$coreOptions$cha = this.coreOptions.chainConfig) === null || _this$coreOptions$cha === void 0 ? void 0 : _this$coreOptions$cha.chainId, clientId)), chainConfig);
          if (!privateKeyProvider) {
            throw base_.WalletInitializationError.invalidParams("privateKeyProvider is required");
          }
          const finalAuthAdapterSettings = objectSpread2_default()(objectSpread2_default()({}, defaultOptions.adapterSettings), {}, {
            clientId,
            network: web3AuthNetwork,
            whiteLabel: this.options.uiConfig
          });
          if (smsOtpEnabled !== undefined) {
            finalAuthAdapterSettings.loginConfig = {
              [auth_adapter_namespaceObject.LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
                showOnModal: smsOtpEnabled,
                showOnDesktop: smsOtpEnabled,
                showOnMobile: smsOtpEnabled,
                showOnSocialBackupFactor: smsOtpEnabled
              }
            };
          }
          if (whitelist) {
            finalAuthAdapterSettings.originData = whitelist.signed_urls;
          }
          if (this.options.uiConfig.uxMode) {
            finalAuthAdapterSettings.uxMode = this.options.uiConfig.uxMode;
          }
          const authAdapter = new auth_adapter_namespaceObject.AuthAdapter(objectSpread2_default()(objectSpread2_default()({}, defaultOptions), {}, {
            clientId,
            useCoreKitKey,
            chainConfig: objectSpread2_default()({}, finalChainConfig),
            adapterSettings: finalAuthAdapterSettings,
            sessionTime,
            web3AuthNetwork,
            privateKeyProvider
          }));
          this.walletAdapters[adapterName] = authAdapter;
          return adapterName;
        }
        throw base_.WalletInitializationError.invalidParams(`Adapter ${adapterName} is not configured`);
      } else if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === base_.ADAPTER_CATEGORY.IN_APP || (adapter === null || adapter === void 0 ? void 0 : adapter.type) === base_.ADAPTER_CATEGORY.EXTERNAL || adapterName === this.cachedAdapter) {
        var _this$modalConfig$ada4;
        if (!((_this$modalConfig$ada4 = this.modalConfig.adapters) !== null && _this$modalConfig$ada4 !== void 0 && _this$modalConfig$ada4[adapterName].showOnModal)) return;
        // add client id to adapter, same web3auth client id can be used in adapter.
        // this id is being overridden if user is also passing client id in adapter's constructor.
        this.walletAdapters[adapterName].setAdapterSettings({
          clientId: this.options.clientId,
          sessionTime: this.options.sessionTime,
          web3AuthNetwork: this.options.web3AuthNetwork,
          useCoreKitKey: this.coreOptions.useCoreKitKey
        });

        // if adapter doesn't have any chainConfig then we will set the chainConfig based of passed chainNamespace
        // and chainNamespace.
        if (!adapter.chainConfigProxy) {
          var _this$coreOptions$cha2;
          const chainConfig = objectSpread2_default()(objectSpread2_default()({}, (0,base_.getChainConfig)(providedChainConfig.chainNamespace, (_this$coreOptions$cha2 = this.coreOptions.chainConfig) === null || _this$coreOptions$cha2 === void 0 ? void 0 : _this$coreOptions$cha2.chainId, this.coreOptions.clientId)), this.coreOptions.chainConfig);
          this.walletAdapters[adapterName].setAdapterSettings({
            chainConfig
          });
        }
        if (adapterName === base_.WALLET_ADAPTERS.AUTH) {
          var _this$options$uiConfi;
          const authAdapter = this.walletAdapters[adapterName];
          if (this.coreOptions.privateKeyProvider) {
            if (authAdapter.currentChainNamespace !== this.coreOptions.privateKeyProvider.currentChainConfig.chainNamespace) {
              throw base_.WalletInitializationError.incompatibleChainNameSpace("private key provider is not compatible with provided chainNamespace for auth adapter");
            }
            authAdapter.setAdapterSettings({
              privateKeyProvider: this.coreOptions.privateKeyProvider
            });
          }
          if (smsOtpEnabled !== undefined) {
            authAdapter.setAdapterSettings({
              loginConfig: {
                [auth_adapter_namespaceObject.LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
                  showOnModal: smsOtpEnabled,
                  showOnDesktop: smsOtpEnabled,
                  showOnMobile: smsOtpEnabled,
                  showOnSocialBackupFactor: smsOtpEnabled
                }
              }
            });
          }
          if (whitelist) {
            authAdapter.setAdapterSettings({
              originData: whitelist.signed_urls
            });
          }
          if ((_this$options$uiConfi = this.options.uiConfig) !== null && _this$options$uiConfi !== void 0 && _this$options$uiConfi.uxMode) {
            authAdapter.setAdapterSettings({
              uxMode: this.options.uiConfig.uxMode
            });
          }
          authAdapter.setAdapterSettings({
            whiteLabel: this.options.uiConfig
          });
          if (!authAdapter.privateKeyProvider) {
            throw base_.WalletInitializationError.invalidParams("privateKeyProvider is required for auth adapter");
          }
        } else if (adapterName === base_.WALLET_ADAPTERS.WALLET_CONNECT_V2) {
          const walletConnectAdapter = this.walletAdapters[adapterName];
          const {
            wallet_connect_enabled: walletConnectEnabled,
            wallet_connect_project_id: walletConnectProjectId
          } = projectConfig;
          if (walletConnectEnabled === false) {
            var _this$modalConfig$ada5, _this$modalConfig$ada6, _this$modalConfig$ada7;
            // override user specified config by hiding wallet connect
            this.modalConfig.adapters = objectSpread2_default()(objectSpread2_default()({}, (_this$modalConfig$ada5 = this.modalConfig.adapters) !== null && _this$modalConfig$ada5 !== void 0 ? _this$modalConfig$ada5 : {}), {}, {
              [base_.WALLET_ADAPTERS.WALLET_CONNECT_V2]: objectSpread2_default()(objectSpread2_default()({}, (_this$modalConfig$ada6 = (_this$modalConfig$ada7 = this.modalConfig.adapters) === null || _this$modalConfig$ada7 === void 0 ? void 0 : _this$modalConfig$ada7[base_.WALLET_ADAPTERS.WALLET_CONNECT_V2]) !== null && _this$modalConfig$ada6 !== void 0 ? _this$modalConfig$ada6 : {}), {}, {
                showOnModal: false
              })
            });
            this.modalConfig.adapters[base_.WALLET_ADAPTERS.WALLET_CONNECT_V2].showOnModal = false;
          } else {
            var _walletConnectAdapter;
            if (!(walletConnectAdapter !== null && walletConnectAdapter !== void 0 && (_walletConnectAdapter = walletConnectAdapter.adapterOptions) !== null && _walletConnectAdapter !== void 0 && (_walletConnectAdapter = _walletConnectAdapter.adapterSettings) !== null && _walletConnectAdapter !== void 0 && (_walletConnectAdapter = _walletConnectAdapter.walletConnectInitOptions) !== null && _walletConnectAdapter !== void 0 && _walletConnectAdapter.projectId) && !walletConnectProjectId) throw base_.WalletInitializationError.invalidParams("Invalid wallet connect project id. Please configure it on the dashboard");
            if (walletConnectProjectId) {
              walletConnectAdapter.setAdapterSettings({
                adapterSettings: {
                  walletConnectInitOptions: {
                    projectId: walletConnectProjectId
                  }
                }
              });
            }
          }
        }
        return adapterName;
      }
    });
    const adapterNames = await Promise.all(adapterConfigurationPromises);
    const hasInAppWallets = Object.values(this.walletAdapters).some(adapter => {
      var _this$modalConfig$ada8, _this$modalConfig$ada9, _adapter$name;
      if (adapter.type !== base_.ADAPTER_CATEGORY.IN_APP) return false;
      if (((_this$modalConfig$ada8 = this.modalConfig.adapters) === null || _this$modalConfig$ada8 === void 0 || (_this$modalConfig$ada8 = _this$modalConfig$ada8[adapter.name]) === null || _this$modalConfig$ada8 === void 0 ? void 0 : _this$modalConfig$ada8.showOnModal) !== true) return false;
      if (!((_this$modalConfig$ada9 = this.modalConfig.adapters) !== null && _this$modalConfig$ada9 !== void 0 && (_this$modalConfig$ada9 = _this$modalConfig$ada9[adapter.name]) !== null && _this$modalConfig$ada9 !== void 0 && _this$modalConfig$ada9.loginMethods)) return true;
      const mergedLoginMethods = (0,ui_namespaceObject.getAdapterSocialLogins)(adapter.name, (_adapter$name = this.modalConfig.adapters[adapter.name]) === null || _adapter$name === void 0 ? void 0 : _adapter$name.loginMethods);
      if (Object.values(mergedLoginMethods).some(method => method.showOnModal)) return true;
      return false;
    });
    base_.log.debug(hasInAppWallets, this.walletAdapters, adapterNames, "hasInAppWallets");

    // Now, initialize the adapters.
    const initPromises = adapterNames.map(async adapterName => {
      if (!adapterName) return;
      try {
        const adapter = this.walletAdapters[adapterName];
        // only initialize a external adapter here if it is a cached adapter.
        if (this.cachedAdapter !== adapterName && adapter.type === base_.ADAPTER_CATEGORY.EXTERNAL) {
          return;
        }
        // in-app wallets or cached wallet (being connected or already connected) are initialized first.
        // if adapter is configured then only initialize in app or cached adapter.
        // external wallets are initialized on INIT_EXTERNAL_WALLET event.
        this.subscribeToAdapterEvents(adapter);
        if (adapter.status === base_.ADAPTER_STATUS.NOT_READY) await adapter.init({
          autoConnect: this.cachedAdapter === adapterName
        });
        // note: not adding cachedWallet to modal if it is external wallet.
        // adding it later if no in-app wallets are available.
        if (adapter.type === base_.ADAPTER_CATEGORY.IN_APP) {
          this.initializeInAppWallet(adapterName);
        }
      } catch (error) {
        base_.log.error(error, "error while initializing adapter ", adapterName);
      }
    });
    this.commonJRPCProvider = await base_provider_namespaceObject.CommonJRPCProvider.getProviderInstance({
      chainConfig: this.coreOptions.chainConfig
    });
    if (typeof keyExportEnabled === "boolean") {
      this.coreOptions.privateKeyProvider.setKeyExportFlag(keyExportEnabled);
      // dont know if we need to do this.
      this.commonJRPCProvider.setKeyExportFlag(keyExportEnabled);
    }
    await Promise.all(initPromises);
    if (this.status === base_.ADAPTER_STATUS.NOT_READY) {
      this.status = base_.ADAPTER_STATUS.READY;
      this.emit(base_.ADAPTER_EVENTS.READY);
    }
    const hasExternalWallets = allAdapters.some(adapterName => {
      var _params4, _this$walletAdapters$, _this$modalConfig$ada10;
      // if wallet connect adapter is available but hideWalletDiscovery is true then don't consider it as external wallet
      if (adapterName === base_.WALLET_ADAPTERS.WALLET_CONNECT_V2 && (_params4 = params) !== null && _params4 !== void 0 && _params4.hideWalletDiscovery) return false;
      return ((_this$walletAdapters$ = this.walletAdapters[adapterName]) === null || _this$walletAdapters$ === void 0 ? void 0 : _this$walletAdapters$.type) === base_.ADAPTER_CATEGORY.EXTERNAL && ((_this$modalConfig$ada10 = this.modalConfig.adapters) === null || _this$modalConfig$ada10 === void 0 ? void 0 : _this$modalConfig$ada10[adapterName].showOnModal);
    });
    if (hasExternalWallets) {
      this.loginModal.initExternalWalletContainer();
    }

    // variable to check if we have any in app wallets
    // currently all default in app and external wallets can be hidden or shown based on config.
    if (!hasInAppWallets && hasExternalWallets) {
      // if no in app wallet is available then initialize external wallets in modal
      await this.initExternalWalletAdapters(false, {
        showExternalWalletsOnly: true
      });
    }
  }
  async connect() {
    if (!this.loginModal) throw base_.WalletInitializationError.notReady("Login modal is not initialized");
    // if already connected return provider
    if (this.connectedAdapterName && this.status === base_.ADAPTER_STATUS.CONNECTED && this.provider) return this.provider;
    this.loginModal.open();
    return new Promise((resolve, reject) => {
      this.once(base_.ADAPTER_EVENTS.CONNECTED, () => {
        return resolve(this.provider);
      });
      this.once(base_.ADAPTER_EVENTS.ERRORED, err => {
        return reject(err);
      });
      this.once(ui_namespaceObject.LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, visibility => {
        // modal is closed but user is not connected to any wallet.
        if (!visibility && this.status !== base_.ADAPTER_STATUS.CONNECTED) {
          return reject(new Error("User closed the modal"));
        }
      });
    });
  }
  async initExternalWalletAdapters(externalWalletsInitialized, options) {
    if (externalWalletsInitialized) return;
    const adaptersConfig = {};
    // we do it like this because we don't want one slow adapter to delay the load of the entire external wallet section.
    Object.keys(this.walletAdapters).forEach(async adapterName => {
      const adapter = this.walletAdapters[adapterName];
      if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === base_.ADAPTER_CATEGORY.EXTERNAL) {
        base_.log.debug("init external wallet", this.cachedAdapter, adapterName, adapter.status);
        this.subscribeToAdapterEvents(adapter);
        // we are not initializing cached adapter here as it is already being initialized in initModal before.
        if (this.cachedAdapter === adapterName) {
          return;
        }
        if (adapter.status === base_.ADAPTER_STATUS.NOT_READY) {
          await adapter.init({
            autoConnect: this.cachedAdapter === adapterName
          }).then(() => {
            const adapterModalConfig = this.modalConfig.adapters[adapterName];
            adaptersConfig[adapterName] = objectSpread2_default()(objectSpread2_default()({}, adapterModalConfig), {}, {
              isInjected: adapter.isInjected
            });
            this.loginModal.addWalletLogins(adaptersConfig, {
              showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
            });
            return undefined;
          }).catch(error => base_.log.error(error, "error while initializing adapter", adapterName));
        } else if (adapter.status === base_.ADAPTER_STATUS.READY || adapter.status === base_.ADAPTER_STATUS.CONNECTING) {
          // we use connecting status for wallet connect
          const adapterModalConfig = this.modalConfig.adapters[adapterName];
          adaptersConfig[adapterName] = objectSpread2_default()(objectSpread2_default()({}, adapterModalConfig), {}, {
            isInjected: adapter.isInjected
          });
          this.loginModal.addWalletLogins(adaptersConfig, {
            showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
          });
        }
      }
    });
  }
  initializeInAppWallet(adapterName) {
    base_.log.info("adapterInitResults", adapterName);
    if (this.walletAdapters[adapterName].type === base_.ADAPTER_CATEGORY.IN_APP) {
      var _adapterName, _this$options$uiConfi2, _this$options$uiConfi3, _this$options$uiConfi4;
      this.loginModal.addSocialLogins(adapterName, (0,ui_namespaceObject.getAdapterSocialLogins)(adapterName, (_adapterName = this.modalConfig.adapters[adapterName]) === null || _adapterName === void 0 ? void 0 : _adapterName.loginMethods), ((_this$options$uiConfi2 = this.options.uiConfig) === null || _this$options$uiConfi2 === void 0 ? void 0 : _this$options$uiConfi2.loginMethodsOrder) || ui_namespaceObject.AUTH_PROVIDERS, objectSpread2_default()(objectSpread2_default()({}, this.options.uiConfig), {}, {
        loginGridCol: ((_this$options$uiConfi3 = this.options.uiConfig) === null || _this$options$uiConfi3 === void 0 ? void 0 : _this$options$uiConfi3.loginGridCol) || 3,
        primaryButton: ((_this$options$uiConfi4 = this.options.uiConfig) === null || _this$options$uiConfi4 === void 0 ? void 0 : _this$options$uiConfi4.primaryButton) || "socialLogin"
      }));
    }
  }
  subscribeToLoginModalEvents() {
    this.loginModal.on(ui_namespaceObject.LOGIN_MODAL_EVENTS.LOGIN, async params => {
      try {
        await this.connectTo(params.adapter, params.loginParams);
      } catch (error) {
        base_.log.error(`Error while connecting to adapter: ${params.adapter}`, error);
      }
    });
    this.loginModal.on(ui_namespaceObject.LOGIN_MODAL_EVENTS.INIT_EXTERNAL_WALLETS, async params => {
      await this.initExternalWalletAdapters(params.externalWalletsInitialized);
    });
    this.loginModal.on(ui_namespaceObject.LOGIN_MODAL_EVENTS.DISCONNECT, async () => {
      try {
        await this.logout();
      } catch (error) {
        base_.log.error(`Error while disconnecting`, error);
      }
    });
    this.loginModal.on(ui_namespaceObject.LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, async visibility => {
      base_.log.debug("is login modal visible", visibility);
      this.emit(ui_namespaceObject.LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, visibility);
      const adapter = this.walletAdapters[base_.WALLET_ADAPTERS.WALLET_CONNECT_V2];
      if (adapter) {
        const walletConnectStatus = adapter === null || adapter === void 0 ? void 0 : adapter.status;
        base_.log.debug("trying refreshing wc session", visibility, walletConnectStatus);
        if (visibility && (walletConnectStatus === base_.ADAPTER_STATUS.READY || walletConnectStatus === base_.ADAPTER_STATUS.CONNECTING)) {
          base_.log.debug("refreshing wc session");

          // refreshing session for wallet connect whenever modal is opened.
          try {
            adapter.connect();
          } catch (error) {
            base_.log.error(`Error while disconnecting to wallet connect in core`, error);
          }
        }
        if (!visibility && this.status === base_.ADAPTER_STATUS.CONNECTED && (walletConnectStatus === base_.ADAPTER_STATUS.READY || walletConnectStatus === base_.ADAPTER_STATUS.CONNECTING)) {
          base_.log.debug("this stops wc adapter from trying to reconnect once proposal expires");
          adapter.status = base_.ADAPTER_STATUS.READY;
        }
      }
    });
  }
}

/***/ }),

/***/ 377:
/***/ ((module) => {

"use strict";
module.exports = require("@web3auth/base");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Web3Auth: () => (/* reexport safe */ _modalManager__WEBPACK_IMPORTED_MODULE_2__.y),
/* harmony export */   defaultEvmDappModalConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.g2),
/* harmony export */   defaultEvmWalletModalConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.eA),
/* harmony export */   defaultOtherModalConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.Lu),
/* harmony export */   defaultSolanaDappModalConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.Gu),
/* harmony export */   defaultSolanaWalletModalConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.KT),
/* harmony export */   walletRegistryUrl: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.e4)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(149);
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(624);
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_interface__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _interface__WEBPACK_IMPORTED_MODULE_1__) if(["default","defaultEvmDappModalConfig","defaultEvmWalletModalConfig","defaultOtherModalConfig","defaultSolanaDappModalConfig","defaultSolanaWalletModalConfig","walletRegistryUrl"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _interface__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _modalManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(430);



})();

module.exports = __webpack_exports__;
/******/ })()
;