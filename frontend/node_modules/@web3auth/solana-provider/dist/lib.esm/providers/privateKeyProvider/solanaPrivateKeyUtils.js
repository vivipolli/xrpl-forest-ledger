import { Keypair, VersionedTransaction } from '@solana/web3.js';
import nacl from '@toruslabs/tweetnacl-js';
import { providerErrors, rpcErrors } from '@web3auth/auth';
import { WalletInitializationError } from '@web3auth/base';
import bs58 from 'bs58';

async function getProviderHandlers({
  privKey,
  keyExportEnabled,
  getProviderEngineProxy
}) {
  const keyPairGenerator = () => {
    return Keypair.fromSecretKey(Buffer.from(privKey, "hex"));
  };
  if (typeof privKey !== "string") throw WalletInitializationError.invalidParams("privKey must be a string");
  const keyPair = keyPairGenerator();
  const providerHandlers = {
    requestAccounts: async () => {
      return [keyPair.publicKey.toBase58()];
    },
    getAccounts: async () => [keyPair.publicKey.toBase58()],
    getPublicKey: async () => keyPair.publicKey.toBase58(),
    getPrivateKey: async () => {
      if (!keyExportEnabled) {
        throw providerErrors.custom({
          message: "Private key export is disabled",
          code: 4902
        });
      }
      return privKey;
    },
    getSecretKey: async () => bs58.encode(keyPair.secretKey),
    signTransaction: async req => {
      var _req$params;
      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {
        throw rpcErrors.invalidParams("message");
      }
      const transaction = req.params.message;
      if (transaction.version !== undefined || transaction instanceof VersionedTransaction) {
        transaction.sign([keyPair]);
      } else {
        transaction.partialSign(keyPair);
      }
      return transaction;
    },
    signMessage: async req => {
      var _req$params2;
      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {
        throw rpcErrors.invalidParams("message");
      }
      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);
      return signedMsg;
    },
    signAndSendTransaction: async req => {
      var _req$params3;
      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {
        throw rpcErrors.invalidParams("message");
      }
      const _providerEngineProxy = getProviderEngineProxy();
      if (!_providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const transaction = req.params.message;
      if (transaction.version !== undefined || transaction instanceof VersionedTransaction) {
        transaction.sign([keyPair]);
      } else {
        transaction.partialSign(keyPair);
      }
      const sig = await _providerEngineProxy.request({
        method: "sendTransaction",
        params: [Buffer.from(transaction.serialize()).toString("base64"), {
          encoding: "base64",
          preflightCommitment: "confirmed"
        }]
      });
      return {
        signature: sig
      };
    },
    signAllTransactions: async req => {
      var _req$params4, _req$params5, _req$params6;
      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {
        throw rpcErrors.invalidParams("message");
      }
      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;
      for (const tx of txns || []) {
        const transaction = tx;
        if (transaction.version !== undefined || transaction instanceof VersionedTransaction) {
          transaction.sign([keyPair]);
        } else {
          transaction.partialSign(keyPair);
        }
      }
      return txns;
    }
  };
  return providerHandlers;
}

export { getProviderHandlers };
