import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { providerErrors, getED25519Key, JRPCEngine, providerFromEngine, rpcErrors } from '@web3auth/auth';
import { CHAIN_NAMESPACES, WalletInitializationError } from '@web3auth/base';
import { BaseProvider } from '@web3auth/base-provider';
import { createJsonRpcClient } from '../../rpc/JrpcClient.js';
import { createSolanaMiddleware, createChainSwitchMiddleware, createAccountMiddleware } from '../../rpc/solanaRpcMiddlewares.js';
import { getProviderHandlers } from './solanaPrivateKeyUtils.js';

var _SolanaPrivateKeyProvider;
class SolanaPrivateKeyProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", CHAIN_NAMESPACES.SOLANA);
  }
  async enable() {
    if (!this.state.privateKey) throw providerErrors.custom({
      message: "Private key is not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.privateKey);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  getEd25519Key(privateKey) {
    return getED25519Key(privateKey).sk.toString("hex").padStart(128, "0");
  }
  async setupProvider(privKey) {
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const providerHandlers = await getProviderHandlers({
      privKey,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this),
      keyExportEnabled: this.config.keyExportEnabled
    });
    const solanaMiddleware = createSolanaMiddleware(providerHandlers);
    const engine = new JRPCEngine();
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(this.getChainSwitchMiddleware());
    engine.push(this.getAccountMiddleware());
    engine.push(solanaMiddleware);
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async updateAccount(params) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const existingKey = await this._providerEngineProxy.request({
      method: "solanaPrivateKey"
    });
    if (existingKey !== params.privateKey) {
      await this.setupProvider(params.privateKey);
      const accounts = await this._providerEngineProxy.request({
        method: "requestAccounts"
      });
      this.emit("accountsChanged", accounts);
    }
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    const privKey = await this._providerEngineProxy.request({
      method: "solanaPrivateKey"
    });
    await this.setupProvider(privKey);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const health = await this._providerEngineProxy.request({
      method: "getHealth",
      params: []
    });
    const {
      chainConfig
    } = this.config;
    if (health !== "ok") throw WalletInitializationError.rpcConnectionError(`Failed to lookup network for following rpc target: ${chainConfig.rpcTarget}`);
    this.update({
      chainId: chainConfig.chainId
    });
    if (this.state.chainId !== chainConfig.chainId) {
      this.emit("chainChanged", this.state.chainId);
      this.emit("connect", {
        chainId: this.state.chainId
      });
    }
    return this.state.chainId;
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addNewChainConfig: async req => {
        if (!req.params) throw rpcErrors.invalidParams("Missing request params");
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency,
          iconUrls
        } = req.params;
        if (!chainId) throw rpcErrors.invalidParams("Missing chainId in chainParams");
        if (!rpcUrls || rpcUrls.length === 0) throw rpcErrors.invalidParams("Missing rpcUrls in chainParams");
        if (!nativeCurrency) throw rpcErrors.invalidParams("Missing nativeCurrency in chainParams");
        this.addChain({
          chainNamespace: CHAIN_NAMESPACES.SOLANA,
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "SOL",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Solana",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorerUrl: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || "",
          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 9,
          logo: (iconUrls === null || iconUrls === void 0 ? void 0 : iconUrls[0]) || "https://images.toruswallet.io/sol.svg"
        });
      },
      switchSolanaChain: async req => {
        if (!req.params) throw rpcErrors.invalidParams("Missing request params");
        if (!req.params.chainId) throw rpcErrors.invalidParams("Missing chainId");
        await this.switchChain(req.params);
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
  getAccountMiddleware() {
    const accountHandlers = {
      updatePrivatekey: async req => {
        if (!req.params) throw rpcErrors.invalidParams("Missing request params");
        if (!req.params.privateKey) throw rpcErrors.invalidParams("Missing privateKey");
        const {
          privateKey
        } = req.params;
        await this.updateAccount({
          privateKey
        });
      }
    };
    return createAccountMiddleware(accountHandlers);
  }
}
_SolanaPrivateKeyProvider = SolanaPrivateKeyProvider;
_defineProperty(SolanaPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _SolanaPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});

export { SolanaPrivateKeyProvider };
