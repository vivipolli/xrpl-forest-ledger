import { rpcErrors } from '@web3auth/auth';
import bs58 from 'bs58';

const getBaseProviderHandlers = injectedProvider => {
  const providerHandlers = {
    requestAccounts: async () => {
      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];
    },
    getPublicKey: async () => {
      return injectedProvider.publicKey ? bs58.encode(injectedProvider.publicKey.toBytes()) : "";
    },
    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],
    getPrivateKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    getSecretKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    signTransaction: async req => {
      const transaction = await injectedProvider.signTransaction(req.params.message);
      return transaction;
    },
    signMessage: async req => {
      const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);
      return sigData.signature;
    },
    signAllTransactions: async req => {
      var _req$params, _req$params2;
      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {
        throw rpcErrors.invalidParams("message");
      }
      const transaction = await injectedProvider.signAllTransactions(req.params.message);
      return transaction;
    },
    signAndSendTransaction: async req => {
      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);
      return {
        signature: txRes.signature
      };
    }
  };
  return providerHandlers;
};

export { getBaseProviderHandlers };
