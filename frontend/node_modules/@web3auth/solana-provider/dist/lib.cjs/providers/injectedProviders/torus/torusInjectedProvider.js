'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var baseProvider = require('@web3auth/base-provider');
var solanaRpcMiddlewares = require('../../../rpc/solanaRpcMiddlewares.js');
var injectedProviderProxy = require('../injectedProviderProxy.js');
var providerHandlers = require('./providerHandlers.js');

class TorusInjectedProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", "solana");
  }
  async switchChain(params) {
    // overrides the base provider implementation
    await this.provider.request({
      method: "switchSolanaChain",
      params: [{
        chainId: params.chainId
      }]
    });
  }
  async addChain(chainConfig) {
    super.addChain(chainConfig);
    await this.provider.request({
      method: "addNewChainConfig",
      params: [{
        chainId: chainConfig.chainId,
        chainName: chainConfig.displayName,
        rpcUrls: [chainConfig.rpcTarget],
        blockExplorerUrls: [chainConfig.blockExplorerUrl],
        iconUrls: [chainConfig.logo],
        nativeCurrency: {
          name: chainConfig.tickerName,
          symbol: chainConfig.ticker,
          decimals: chainConfig.decimals || 18
        }
      }]
    });
  }
  async setupProvider(injectedProvider) {
    this.handleInjectedProviderUpdate(injectedProvider);
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    await this.setupEngine(injectedProvider);
  }
  async lookupNetwork() {
    if (!this.provider) throw auth.providerErrors.custom({
      message: "Torus solana provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    const connectedChainId = await this.provider.request({
      method: "solana_chainId"
    });
    const connectedHexChainId = base.isHexStrict(connectedChainId.toString()) ? connectedChainId : `0x${parseInt(connectedChainId, 10).toString(16)}`;
    if (chainId !== connectedHexChainId) throw base.WalletInitializationError.rpcConnectionError(`Invalid network, net_version is: ${connectedHexChainId}, expected: ${chainId}`);
    this.update({
      chainId: connectedHexChainId
    });
    this.emit("connect", {
      chainId: this.state.chainId
    });
    this.emit("chainChanged", this.state.chainId);
    return this.state.chainId;
  }
  async setupEngine(injectedProvider) {
    const providerHandlers$1 = providerHandlers.getTorusHandlers(injectedProvider);
    const solanaMiddleware = solanaRpcMiddlewares.createSolanaMiddleware(providerHandlers$1);
    const injectedProviderProxy$1 = injectedProviderProxy.createInjectedProviderProxyMiddleware(injectedProvider);
    const engine = new auth.JRPCEngine();
    engine.push(solanaMiddleware);
    engine.push(injectedProviderProxy$1);
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async handleInjectedProviderUpdate(injectedProvider) {
    injectedProvider.on("accountsChanged", async accounts => {
      this.emit("accountsChanged", accounts);
    });
    injectedProvider.on("chainChanged", async chainId => {
      const connectedHexChainId = base.isHexStrict(chainId) ? chainId : `0x${parseInt(chainId, 10).toString(16)}`;
      // Check if chainId changed and trigger event
      this.configure({
        chainConfig: _objectSpread(_objectSpread({}, this.config.chainConfig), {}, {
          chainId: connectedHexChainId
        })
      });
      await this.setupProvider(injectedProvider);
    });
  }
}

exports.TorusInjectedProvider = TorusInjectedProvider;
