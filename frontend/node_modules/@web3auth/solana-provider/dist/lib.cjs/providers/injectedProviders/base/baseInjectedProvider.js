'use strict';

var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var baseProvider = require('@web3auth/base-provider');
var JrpcClient = require('../../../rpc/JrpcClient.js');
var solanaRpcMiddlewares = require('../../../rpc/solanaRpcMiddlewares.js');

class BaseInjectedProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
  }
  async switchChain(_) {
    throw base.WalletLoginError.unsupportedOperation("Chain switching is not supported by this adapter");
  }
  async setupProvider(injectedProvider) {
    const engine = new auth.JRPCEngine();
    const providerHandlers = this.getProviderHandlers(injectedProvider);
    const solanaMiddleware = solanaRpcMiddlewares.createSolanaMiddleware(providerHandlers);
    engine.push(solanaMiddleware);
    const configMiddleware = JrpcClient.createConfigMiddleware(this.config.chainConfig);
    engine.push(configMiddleware);
    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);
    if (injectedProviderProxy) {
      engine.push(injectedProviderProxy);
    }
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await this.lookupNetwork();
  }
  async lookupNetwork() {
    const {
      chainConfig
    } = this.config;
    this.update({
      chainId: chainConfig.chainId
    });
    return chainConfig.chainId || "";
  }
  getInjectedProviderProxy(_) {
    return undefined;
  }
}

exports.BaseInjectedProvider = BaseInjectedProvider;
