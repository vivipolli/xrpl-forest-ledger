import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController, createEventEmitterProxy } from '@toruslabs/base-controllers';
import { rpcErrors } from '@web3auth/auth';
import { WalletInitializationError, WalletProviderError } from '@web3auth/base';

class BaseProvider extends BaseController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    // should be Assigned in setupProvider
    _defineProperty(this, "_providerEngineProxy", null);
    // set to true when the keyExportEnabled flag is set by code.
    // This is to prevent the flag from being overridden by the dashboard config.
    _defineProperty(this, "keyExportFlagSetByCode", false);
    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError("Please provide chainConfig");
    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError("Please provide chainId inside chainConfig");
    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");
    if (typeof config.keyExportEnabled === "boolean") this.keyExportFlagSetByCode = true;
    this.defaultState = {
      chainId: "loading"
    };
    this.defaultConfig = {
      chainConfig: config.chainConfig,
      networks: {
        [config.chainConfig.chainId]: config.chainConfig
      },
      keyExportEnabled: typeof config.keyExportEnabled === "boolean" ? config.keyExportEnabled : true
    };
    super.initialize();
  }
  get currentChainConfig() {
    return this.config.chainConfig;
  }
  get provider() {
    return this._providerEngineProxy;
  }
  get chainId() {
    return this.state.chainId;
  }
  set provider(_) {
    throw new Error("Method not implemented.");
  }
  async request(args) {
    var _this$provider;
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestArgs().message,
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: WalletProviderError.invalidRequestArgs().message
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestMethod().message,
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: WalletProviderError.invalidRequestMethod().message
        })
      });
    }
    if (params !== undefined && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestParams().message,
        data: _objectSpread(_objectSpread({}, args || {}), {}, {
          cause: WalletProviderError.invalidRequestParams().message
        })
      });
    }
    return (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.request(args);
  }
  sendAsync(req, callback) {
    if (callback) return this.send(req, callback);
    return this.request(req);
  }
  send(req, callback) {
    this.request(req).then(res => callback(null, {
      result: res
    })).catch(err => callback(err, null));
  }
  addChain(chainConfig) {
    if (!chainConfig.chainId) throw rpcErrors.invalidParams("chainId is required");
    if (!chainConfig.rpcTarget) throw rpcErrors.invalidParams("chainId is required");
    this.configure({
      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {
        [chainConfig.chainId]: chainConfig
      })
    });
  }
  getChainConfig(chainId) {
    var _this$config$networks;
    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];
    if (!chainConfig) throw rpcErrors.invalidRequest(`Chain ${chainId} is not supported, please add chainConfig for it`);
    return chainConfig;
  }
  updateProviderEngineProxy(provider) {
    if (this._providerEngineProxy) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._providerEngineProxy.setTarget(provider);
    } else {
      this._providerEngineProxy = createEventEmitterProxy(provider);
    }
  }
  setKeyExportFlag(flag) {
    if (!this.keyExportFlagSetByCode) {
      this.configure({
        keyExportEnabled: flag
      });
    }
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
}

export { BaseProvider };
