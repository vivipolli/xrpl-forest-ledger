import { BaseConfig, BaseController, BaseState } from "@toruslabs/base-controllers";
import { JRPCRequest, JRPCResponse, SendCallBack } from "@web3auth/auth";
import { CustomChainConfig, IBaseProvider, Maybe, RequestArguments, SafeEventEmitterProvider } from "@web3auth/base";
import { BaseProviderEvents } from "./interfaces";
export interface BaseProviderState extends BaseState {
    chainId: string;
}
export interface BaseProviderConfig extends BaseConfig {
    chainConfig: CustomChainConfig;
    networks?: Record<string, CustomChainConfig>;
    skipLookupNetwork?: boolean;
    keyExportEnabled?: boolean;
}
export declare abstract class BaseProvider<C extends BaseProviderConfig, S extends BaseProviderState, P> extends BaseController<C, S, BaseProviderEvents<S>> implements IBaseProvider<P> {
    _providerEngineProxy: SafeEventEmitterProvider | null;
    private keyExportFlagSetByCode;
    constructor({ config, state }: {
        config: C;
        state?: S;
    });
    get currentChainConfig(): CustomChainConfig;
    get provider(): SafeEventEmitterProvider | null;
    get chainId(): string;
    set provider(_: SafeEventEmitterProvider | null);
    request<T, R>(args: RequestArguments<T>): Promise<Maybe<R>>;
    sendAsync<T, U>(req: JRPCRequest<T>, callback: SendCallBack<JRPCResponse<U>>): void;
    sendAsync<T, U>(req: JRPCRequest<T>): Promise<JRPCResponse<U>>;
    send<T, U>(req: JRPCRequest<T>, callback: SendCallBack<JRPCResponse<U>>): void;
    addChain(chainConfig: CustomChainConfig): void;
    getChainConfig(chainId: string): CustomChainConfig | null;
    updateProviderEngineProxy(provider: SafeEventEmitterProvider): void;
    setKeyExportFlag(flag: boolean): void;
    protected getProviderEngineProxy(): SafeEventEmitterProvider | null;
    abstract setupProvider(provider: P): Promise<void>;
    abstract switchChain(params: {
        chainId: string;
    }): Promise<void>;
    protected abstract lookupNetwork(provider?: P): Promise<string | void>;
}
