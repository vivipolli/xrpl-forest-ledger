'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var utils = require('@walletconnect/utils');
var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var base58 = require('bs58');
var config = require('./config.js');

async function getLastActiveSession(signClient) {
  if (signClient.session.length) {
    const lastKeyIndex = signClient.session.keys.length - 1;
    return signClient.session.get(signClient.session.keys[lastKeyIndex]);
  }
  return null;
}
function isMobileDevice() {
  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(window.navigator.userAgent);
}
function isSolanaChain(chainId) {
  return chainId.startsWith("solana:");
}
async function sendJrpcRequest(signClient, chainId, method, params) {
  const session = await getLastActiveSession(signClient);
  if (!session) {
    throw auth.providerErrors.disconnected();
  }
  if (typeof window !== "undefined" && isMobileDevice()) {
    if (session.peer.metadata.redirect && session.peer.metadata.redirect.native) {
      window.open(session.peer.metadata.redirect.native, "_blank");
    }
  }
  return signClient.request({
    topic: session.topic,
    chainId,
    request: {
      method,
      params: isSolanaChain(chainId) ? _objectSpread(_objectSpread({}, params), {}, {
        pubkey: session.self.publicKey
      }) : params
    }
  });
}
async function getAccounts(signClient) {
  const session = await getLastActiveSession(signClient);
  if (!session) {
    throw auth.providerErrors.disconnected();
  }
  const accounts = utils.getAccountsFromNamespaces(session.namespaces);
  if (accounts && accounts.length) {
    return [...new Set(accounts.map(add => {
      return utils.parseAccountId(add).address;
    }))];
  }
  throw base.WalletLoginError.connectionError("Failed to get accounts");
}
function getEthProviderHandlers({
  connector,
  chainId
}) {
  return {
    getPrivateKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getPublicKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getAccounts: async _ => {
      return getAccounts(connector);
    },
    processTransaction: async (txParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "eth_sendTransaction", [txParams]);
      return methodRes;
    },
    processSignTransaction: async (txParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "eth_signTransaction", [txParams]);
      return methodRes;
    },
    processEthSignMessage: async (msgParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "eth_sign", [msgParams.from, msgParams.data]);
      return methodRes;
    },
    processPersonalMessage: async (msgParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "personal_sign", [msgParams.data, msgParams.from]);
      return methodRes;
    },
    processTypedMessageV4: async msgParams => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "eth_signTypedData_v4", [msgParams.from, msgParams.data]);
      return methodRes;
    }
  };
}
function getSolProviderHandlers({
  connector,
  chainId
}) {
  return {
    requestAccounts: async _ => {
      return getAccounts(connector);
    },
    getPrivateKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getSecretKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getPublicKey: async () => {
      throw auth.rpcErrors.methodNotSupported();
    },
    getAccounts: async _ => {
      return getAccounts(connector);
    },
    signAllTransactions: async _ => {
      throw auth.rpcErrors.methodNotSupported();
    },
    signAndSendTransaction: async _ => {
      throw auth.rpcErrors.methodNotSupported();
    },
    signMessage: async req => {
      const methodRes = await sendJrpcRequest(connector, `solana:${config.SOLANA_CAIP_CHAIN_MAP[chainId]}`, "solana_signMessage", {
        message: base58.encode(req.params.message)
      });
      return base58.decode(methodRes.signature);
    },
    signTransaction: async req => {
      const [{
        PublicKey
      }, accounts] = await Promise.all([import('@solana/web3.js'), getAccounts(connector)]);
      if (accounts.length === 0) {
        throw auth.providerErrors.disconnected();
      }
      const methodRes = await sendJrpcRequest(connector, `solana:${config.SOLANA_CAIP_CHAIN_MAP[chainId]}`, "solana_signTransaction", {
        transaction: req.params.message.serialize({
          requireAllSignatures: false
        }).toString("base64")
      });
      const finalTransaction = req.params.message;
      finalTransaction.addSignature(new PublicKey(accounts[0]), Buffer.from(base58.decode(methodRes.signature)));
      return finalTransaction;
    }
  };
}
async function switchChain({
  connector,
  chainId,
  newChainId
}) {
  await sendJrpcRequest(connector, `eip155:${chainId}`, "wallet_switchEthereumChain", [{
    chainId: newChainId
  }]);
}
async function addChain({
  connector,
  chainId,
  chainConfig
}) {
  await sendJrpcRequest(connector, `eip155:${chainId}`, "wallet_addEthereumChain", [chainConfig]);
}

exports.addChain = addChain;
exports.getAccounts = getAccounts;
exports.getEthProviderHandlers = getEthProviderHandlers;
exports.getSolProviderHandlers = getSolProviderHandlers;
exports.sendJrpcRequest = sendJrpcRequest;
exports.switchChain = switchChain;
