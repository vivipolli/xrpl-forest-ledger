import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SolanaSignMessage, SolanaSignTransaction, SolanaSignAndSendTransaction } from '@solana/wallet-standard-features';
import { PublicKey, VersionedTransaction, Transaction } from '@solana/web3.js';
import { SafeEventEmitter } from '@web3auth/auth';
import { WalletLoginError } from '@web3auth/base';
import BN from 'bn.js';

class WalletStandardProviderHandler extends SafeEventEmitter {
  constructor({
    wallet,
    getCurrentChain
  }) {
    super();
    _defineProperty(this, "wallet", null);
    _defineProperty(this, "getCurrentChain", void 0);
    this.wallet = wallet;
    this.getCurrentChain = getCurrentChain;
  }
  get currentAccount() {
    var _this$wallet;
    const account = (_this$wallet = this.wallet) === null || _this$wallet === void 0 ? void 0 : _this$wallet.accounts[0];
    if (!account) throw WalletLoginError.notConnectedError();
    return account;
  }
  get publicKey() {
    return new PublicKey(this.currentAccount.publicKey);
  }
  async signMessage(message) {
    const account = this.currentAccount;
    const signature = await this.wallet.features[SolanaSignMessage].signMessage({
      account,
      message
    });
    return {
      signature: signature[0].signature,
      publicKey: new BN(Buffer.from(account.publicKey))
    };
  }
  async signTransaction(transaction) {
    const account = this.currentAccount;
    const output = await this.wallet.features[SolanaSignTransaction].signTransaction({
      account,
      transaction: transaction.serialize({
        requireAllSignatures: false
      }),
      chain: this.getCurrentChain()
    });
    const isVersionedTransaction = transaction.version !== undefined || transaction instanceof VersionedTransaction;
    if (isVersionedTransaction) {
      return VersionedTransaction.deserialize(output[0].signedTransaction);
    }
    return Transaction.from(output[0].signedTransaction);
  }
  async signAllTransactions(transactions) {
    return Promise.all(transactions.map(transaction => this.signTransaction(transaction)));
  }
  async signAndSendTransaction(transaction) {
    const account = this.currentAccount;
    const output = await this.wallet.features[SolanaSignAndSendTransaction].signAndSendTransaction({
      account,
      transaction: transaction.serialize({
        requireAllSignatures: false
      }),
      chain: this.getCurrentChain()
    });
    const [{
      signature
    }] = output;
    return {
      signature: new TextDecoder().decode(signature)
    };
  }
}

export { WalletStandardProviderHandler };
