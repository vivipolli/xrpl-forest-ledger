'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var walletStandardFeatures = require('@solana/wallet-standard-features');
var web3_js = require('@solana/web3.js');
var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var BN = require('bn.js');

class WalletStandardProviderHandler extends auth.SafeEventEmitter {
  constructor({
    wallet,
    getCurrentChain
  }) {
    super();
    _defineProperty(this, "wallet", null);
    _defineProperty(this, "getCurrentChain", void 0);
    this.wallet = wallet;
    this.getCurrentChain = getCurrentChain;
  }
  get currentAccount() {
    var _this$wallet;
    const account = (_this$wallet = this.wallet) === null || _this$wallet === void 0 ? void 0 : _this$wallet.accounts[0];
    if (!account) throw base.WalletLoginError.notConnectedError();
    return account;
  }
  get publicKey() {
    return new web3_js.PublicKey(this.currentAccount.publicKey);
  }
  async signMessage(message) {
    const account = this.currentAccount;
    const signature = await this.wallet.features[walletStandardFeatures.SolanaSignMessage].signMessage({
      account,
      message
    });
    return {
      signature: signature[0].signature,
      publicKey: new BN(Buffer.from(account.publicKey))
    };
  }
  async signTransaction(transaction) {
    const account = this.currentAccount;
    const output = await this.wallet.features[walletStandardFeatures.SolanaSignTransaction].signTransaction({
      account,
      transaction: transaction.serialize({
        requireAllSignatures: false
      }),
      chain: this.getCurrentChain()
    });
    const isVersionedTransaction = transaction.version !== undefined || transaction instanceof web3_js.VersionedTransaction;
    if (isVersionedTransaction) {
      return web3_js.VersionedTransaction.deserialize(output[0].signedTransaction);
    }
    return web3_js.Transaction.from(output[0].signedTransaction);
  }
  async signAllTransactions(transactions) {
    return Promise.all(transactions.map(transaction => this.signTransaction(transaction)));
  }
  async signAndSendTransaction(transaction) {
    const account = this.currentAccount;
    const output = await this.wallet.features[walletStandardFeatures.SolanaSignAndSendTransaction].signAndSendTransaction({
      account,
      transaction: transaction.serialize({
        requireAllSignatures: false
      }),
      chain: this.getCurrentChain()
    });
    const [{
      signature
    }] = output;
    return {
      signature: new TextDecoder().decode(signature)
    };
  }
}

exports.WalletStandardProviderHandler = WalletStandardProviderHandler;
