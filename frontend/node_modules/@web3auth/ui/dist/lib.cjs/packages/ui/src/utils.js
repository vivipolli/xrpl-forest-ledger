'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var httpHelpers = require('@toruslabs/http-helpers');
var auth = require('@web3auth/auth');
var base = require('@web3auth/base');
var config = require('./config.js');

const getAdapterSocialLogins = (adapterName, loginMethodsConfig = {}) => {
  const finalLoginMethodsConfig = {};
  if (adapterName === base.WALLET_ADAPTERS.AUTH) {
    config.AUTH_PROVIDERS.forEach(loginMethod => {
      const currentLoginMethodConfig = loginMethodsConfig[loginMethod] || {
        name: config.AUTH_PROVIDERS_NAMES[loginMethod],
        showOnMobile: true,
        showOnModal: true,
        showOnDesktop: true
      };
      finalLoginMethodsConfig[loginMethod] = _objectSpread({}, currentLoginMethodConfig);
    });
    base.log.debug("auth login method ui config", finalLoginMethodsConfig);
  } else {
    throw base.WalletInitializationError.invalidParams(`${adapterName} is not a valid adapter`);
  }
  return finalLoginMethodsConfig;
};
async function validateImageUrl(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.src = url;
    if (img.complete) {
      resolve(true);
    } else {
      img.addEventListener("load", () => {
        resolve(true);
      });
      img.addEventListener("error", () => {
        reject();
      });
    }
  });
}
async function getNetworkIconId(ticker) {
  const fallbackId = "network-default";
  if (!ticker) return fallbackId;
  try {
    const url = `https://images.web3auth.io/network-${ticker.toLowerCase()}.svg`;
    const isValid = await validateImageUrl(url);
    if (isValid) {
      return `network-${ticker.toLowerCase()}`;
    }
    return fallbackId;
  } catch {
    return fallbackId;
  }
}
const passwordlessBackendUrl = "https://api-passwordless.web3auth.io";
const getUserCountry = async () => {
  try {
    const result = await httpHelpers.get(`${passwordlessBackendUrl}/api/v3/user/location`);
    if (result && result.data.country) return {
      country: result.data.country,
      dialCode: result.data.dial_code
    };
    return null;
  } catch (error) {
    base.log.error("error getting user country", error);
    return null;
  }
};
const validatePhoneNumber = async phoneNumber => {
  try {
    const result = await httpHelpers.post(`${passwordlessBackendUrl}/api/v3/phone_number/validate`, {
      phone_number: phoneNumber
    });
    if (result && result.success) return result.parsed_number;
    return false;
  } catch (error) {
    base.log.error("error validating phone number", error);
    if (error.status === 400) {
      return false;
    }
    // sending true because we don't want the user to be stuck on a flow
    // if there is an error with the api or something went wrong.
    return true;
  }
};
const getUserLanguage = defaultLanguage => {
  let userLanguage = defaultLanguage;
  if (!userLanguage) {
    const browserLanguage = typeof window !== "undefined" ? window.navigator.userLanguage || window.navigator.language || "en-US" : "en-US";
    userLanguage = browserLanguage.split("-")[0];
  }
  return Object.prototype.hasOwnProperty.call(auth.LANGUAGE_MAP, userLanguage) ? userLanguage : auth.LANGUAGES.en;
};

exports.getAdapterSocialLogins = getAdapterSocialLogins;
exports.getNetworkIconId = getNetworkIconId;
exports.getUserCountry = getUserCountry;
exports.getUserLanguage = getUserLanguage;
exports.passwordlessBackendUrl = passwordlessBackendUrl;
exports.validateImageUrl = validateImageUrl;
exports.validatePhoneNumber = validatePhoneNumber;
