import {
  require_browser
} from "./chunk-XL3JLEEN.js";
import {
  require_buffer
} from "./chunk-OJ46EPHK.js";
import {
  __commonJS
} from "./chunk-MVEJMUOB.js";

// node_modules/fetch-ponyfill/build/fetch-browser.js
var require_fetch_browser = __commonJS({
  "node_modules/fetch-ponyfill/build/fetch-browser.js"(exports, module) {
    (function(global2) {
      "use strict";
      function fetchPonyfill(options) {
        var Promise2 = options && options.Promise || global2.Promise;
        var XMLHttpRequest = options && options.XMLHttpRequest || global2.XMLHttpRequest;
        return function() {
          var globalThis2 = Object.create(global2, {
            fetch: {
              value: void 0,
              writable: true
            }
          });
          (function(global3, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.WHATWGFetch = {});
          })(this, function(exports2) {
            "use strict";
            var global3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global3 !== "undefined" && global3;
            var support = {
              searchParams: "URLSearchParams" in global3,
              iterable: "Symbol" in global3 && "iterator" in Symbol,
              blob: "FileReader" in global3 && "Blob" in global3 && function() {
                try {
                  new Blob();
                  return true;
                } catch (e) {
                  return false;
                }
              }(),
              formData: "FormData" in global3,
              arrayBuffer: "ArrayBuffer" in global3
            };
            function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj);
            }
            if (support.arrayBuffer) {
              var viewClasses = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]"
              ];
              var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
              };
            }
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            function iteratorFor(items) {
              var iterator = {
                next: function() {
                  var value = items.shift();
                  return { done: value === void 0, value };
                }
              };
              if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                  return iterator;
                };
              }
              return iterator;
            }
            function Headers(headers) {
              this.map = {};
              if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }
            Headers.prototype.append = function(name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ", " + value : value;
            };
            Headers.prototype["delete"] = function(name) {
              delete this.map[normalizeName(name)];
            };
            Headers.prototype.get = function(name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null;
            };
            Headers.prototype.has = function(name) {
              return this.map.hasOwnProperty(normalizeName(name));
            };
            Headers.prototype.set = function(name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };
            Headers.prototype.forEach = function(callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };
            Headers.prototype.keys = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push(name);
              });
              return iteratorFor(items);
            };
            Headers.prototype.values = function() {
              var items = [];
              this.forEach(function(value) {
                items.push(value);
              });
              return iteratorFor(items);
            };
            Headers.prototype.entries = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items);
            };
            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }
            function consumed(body) {
              if (body.bodyUsed) {
                return Promise2.reject(new TypeError("Already read"));
              }
              body.bodyUsed = true;
            }
            function fileReaderReady(reader) {
              return new Promise2(function(resolve, reject) {
                reader.onload = function() {
                  resolve(reader.result);
                };
                reader.onerror = function() {
                  reject(reader.error);
                };
              });
            }
            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise;
            }
            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise;
            }
            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);
              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }
              return chars.join("");
            }
            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0);
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
              }
            }
            function Body() {
              this.bodyUsed = false;
              this._initBody = function(body) {
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                  this._bodyText = "";
                } else if (typeof body === "string") {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                  this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                  this._bodyArrayBuffer = bufferClone(body.buffer);
                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get("content-type")) {
                  if (typeof body === "string") {
                    this.headers.set("content-type", "text/plain;charset=UTF-8");
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set("content-type", this._bodyBlob.type);
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                  }
                }
              };
              if (support.blob) {
                this.blob = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected;
                  }
                  if (this._bodyBlob) {
                    return Promise2.resolve(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise2.resolve(new Blob([this._bodyArrayBuffer]));
                  } else if (this._bodyFormData) {
                    throw new Error("could not read FormData body as blob");
                  } else {
                    return Promise2.resolve(new Blob([this._bodyText]));
                  }
                };
                this.arrayBuffer = function() {
                  if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                      return isConsumed;
                    }
                    if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                      return Promise2.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                        )
                      );
                    } else {
                      return Promise2.resolve(this._bodyArrayBuffer);
                    }
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                  }
                };
              }
              this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise2.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as text");
                } else {
                  return Promise2.resolve(this._bodyText);
                }
              };
              if (support.formData) {
                this.formData = function() {
                  return this.text().then(decode);
                };
              }
              this.json = function() {
                return this.text().then(JSON.parse);
              };
              return this;
            }
            var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method;
            }
            function Request(input, options2) {
              if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              options2 = options2 || {};
              var body = options2.body;
              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError("Already read");
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options2.headers) {
                  this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }
              this.credentials = options2.credentials || this.credentials || "same-origin";
              if (options2.headers || !this.headers) {
                this.headers = new Headers(options2.headers);
              }
              this.method = normalizeMethod(options2.method || this.method || "GET");
              this.mode = options2.mode || this.mode || null;
              this.signal = options2.signal || this.signal;
              this.referrer = null;
              if ((this.method === "GET" || this.method === "HEAD") && body) {
                throw new TypeError("Body not allowed for GET or HEAD requests");
              }
              this._initBody(body);
              if (this.method === "GET" || this.method === "HEAD") {
                if (options2.cache === "no-store" || options2.cache === "no-cache") {
                  var reParamSearch = /([?&])_=[^&]*/;
                  if (reParamSearch.test(this.url)) {
                    this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                  } else {
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                  }
                }
              }
            }
            Request.prototype.clone = function() {
              return new Request(this, { body: this._bodyInit });
            };
            function decode(body) {
              var form = new FormData();
              body.trim().split("&").forEach(function(bytes) {
                if (bytes) {
                  var split = bytes.split("=");
                  var name = split.shift().replace(/\+/g, " ");
                  var value = split.join("=").replace(/\+/g, " ");
                  form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
              });
              return form;
            }
            function parseHeaders(rawHeaders) {
              var headers = new Headers();
              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
              preProcessedHeaders.split("\r").map(function(header) {
                return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
              }).forEach(function(line) {
                var parts = line.split(":");
                var key = parts.shift().trim();
                if (key) {
                  var value = parts.join(":").trim();
                  headers.append(key, value);
                }
              });
              return headers;
            }
            Body.call(Request.prototype);
            function Response(bodyInit, options2) {
              if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              if (!options2) {
                options2 = {};
              }
              this.type = "default";
              this.status = options2.status === void 0 ? 200 : options2.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText = "statusText" in options2 ? options2.statusText : "";
              this.headers = new Headers(options2.headers);
              this.url = options2.url || "";
              this._initBody(bodyInit);
            }
            Body.call(Response.prototype);
            Response.prototype.clone = function() {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              });
            };
            Response.error = function() {
              var response = new Response(null, { status: 0, statusText: "" });
              response.type = "error";
              return response;
            };
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError("Invalid status code");
              }
              return new Response(null, { status, headers: { location: url } });
            };
            exports2.DOMException = global3.DOMException;
            try {
              new exports2.DOMException();
            } catch (err) {
              exports2.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
              };
              exports2.DOMException.prototype = Object.create(Error.prototype);
              exports2.DOMException.prototype.constructor = exports2.DOMException;
            }
            function fetch(input, init) {
              return new Promise2(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                  return reject(new exports2.DOMException("Aborted", "AbortError"));
                }
                var xhr = new XMLHttpRequest();
                function abortXhr() {
                  xhr.abort();
                }
                xhr.onload = function() {
                  var options2 = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                  };
                  options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
                  var body = "response" in xhr ? xhr.response : xhr.responseText;
                  setTimeout(function() {
                    resolve(new Response(body, options2));
                  }, 0);
                };
                xhr.onerror = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.ontimeout = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.onabort = function() {
                  setTimeout(function() {
                    reject(new exports2.DOMException("Aborted", "AbortError"));
                  }, 0);
                };
                function fixUrl(url) {
                  try {
                    return url === "" && global3.location.href ? global3.location.href : url;
                  } catch (e) {
                    return url;
                  }
                }
                xhr.open(request.method, fixUrl(request.url), true);
                if (request.credentials === "include") {
                  xhr.withCredentials = true;
                } else if (request.credentials === "omit") {
                  xhr.withCredentials = false;
                }
                if ("responseType" in xhr) {
                  if (support.blob) {
                    xhr.responseType = "blob";
                  } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                    xhr.responseType = "arraybuffer";
                  }
                }
                if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
                  Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                  });
                } else {
                  request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                  });
                }
                if (request.signal) {
                  request.signal.addEventListener("abort", abortXhr);
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      request.signal.removeEventListener("abort", abortXhr);
                    }
                  };
                }
                xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
              });
            }
            fetch.polyfill = true;
            if (!global3.fetch) {
              global3.fetch = fetch;
              global3.Headers = Headers;
              global3.Request = Request;
              global3.Response = Response;
            }
            exports2.Headers = Headers;
            exports2.Request = Request;
            exports2.Response = Response;
            exports2.fetch = fetch;
            Object.defineProperty(exports2, "__esModule", { value: true });
          });
          return {
            fetch: globalThis2.fetch,
            Headers: globalThis2.Headers,
            Request: globalThis2.Request,
            Response: globalThis2.Response,
            DOMException: globalThis2.DOMException
          };
        }();
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return fetchPonyfill;
        });
      } else if (typeof exports === "object") {
        module.exports = fetchPonyfill;
      } else {
        global2.fetchPonyfill = fetchPonyfill;
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports);
  }
});

// node_modules/os-browserify/browser.js
var require_browser2 = __commonJS({
  "node_modules/os-browserify/browser.js"(exports) {
    exports.endianness = function() {
      return "LE";
    };
    exports.hostname = function() {
      if (typeof location !== "undefined") {
        return location.hostname;
      } else return "";
    };
    exports.loadavg = function() {
      return [];
    };
    exports.uptime = function() {
      return 0;
    };
    exports.freemem = function() {
      return Number.MAX_VALUE;
    };
    exports.totalmem = function() {
      return Number.MAX_VALUE;
    };
    exports.cpus = function() {
      return [];
    };
    exports.type = function() {
      return "Browser";
    };
    exports.release = function() {
      if (typeof navigator !== "undefined") {
        return navigator.appVersion;
      }
      return "";
    };
    exports.networkInterfaces = exports.getNetworkInterfaces = function() {
      return {};
    };
    exports.arch = function() {
      return "javascript";
    };
    exports.platform = function() {
      return "browser";
    };
    exports.tmpdir = exports.tmpDir = function() {
      return "/tmp";
    };
    exports.EOL = "\n";
    exports.homedir = function() {
      return "/";
    };
  }
});

// node_modules/xumm-sdk/dist/src/utils.js
var require_utils = __commonJS({
  "node_modules/xumm-sdk/dist/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeferredPromise = exports.throwIfError = void 0;
    function throwIfError(call) {
      var _a, _b, _c, _d, _e, _f;
      const isFatalError = call.message !== void 0;
      if (isFatalError) {
        throw new Error(call.message);
      }
      const isError = call.next === void 0 && ((_b = (_a = call) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.uuid) === void 0 && ((_d = (_c = call) === null || _c === void 0 ? void 0 : _c.application) === null || _d === void 0 ? void 0 : _d.uuidv4) === void 0 && ((_f = (_e = call) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.code) !== void 0;
      if (isError) {
        const e = call.error;
        throw new Error(`Error code ${e.code}, see XUMM Dev Console, reference: ${e.reference}`);
      }
    }
    exports.throwIfError = throwIfError;
    var DeferredPromise = class {
      constructor() {
        this.resolveFn = (_arg) => {
        };
        this.rejectFn = (_arg) => {
        };
        this.promise = new Promise((resolve, reject) => {
          this.resolveFn = resolve;
          this.rejectFn = reject;
        });
      }
      resolve(arg) {
        this.resolveFn(arg);
        return this.promise;
      }
      reject(arg) {
        this.rejectFn(arg);
        return this.promise;
      }
    };
    exports.DeferredPromise = DeferredPromise;
  }
});

// node_modules/xumm-sdk/dist/src/Meta.js
var require_Meta = __commonJS({
  "node_modules/xumm-sdk/dist/src/Meta.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Meta = void 0;
    var debug_1 = require_browser();
    var fetch_ponyfill_1 = __importDefault(require_fetch_browser());
    var { fetch, Request, Response, Headers } = fetch_ponyfill_1.default();
    var os_browserify_1 = require_browser2();
    var utils_1 = require_utils();
    var index_1 = require_src();
    var log = debug_1.debug("xumm-sdk:meta");
    var Meta = class {
      constructor(apiKey, apiSecret) {
        this.isBrowser = false;
        this.jwtFlow = false;
        this.injected = false;
        this.endpoint = "https://xumm.app";
        log("Constructed");
        const uuidRe = new RegExp("^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$");
        const secret = {
          split: apiSecret.split(":"),
          uuidv4: ""
        };
        if (secret.split.length === 3 && secret.split.slice(0, 2).join(":") === "xApp:OneTimeToken") {
          secret.uuidv4 = secret.split[2];
          this.jwtFlow = true;
        } else if (secret.split.length > 1 && secret.split[0] === "RAWJWT") {
          this.jwtFlow = true;
          this.jwt = secret.split.slice(1).join(":");
        } else {
          secret.uuidv4 = apiSecret;
        }
        if (!uuidRe.test(apiKey) || !uuidRe.test(secret.uuidv4)) {
          if (!this.jwtFlow) {
            throw new Error("Invalid API Key and/or API Secret. Use dotenv or constructor params.");
          } else {
            if (!this.jwt) {
              throw new Error("Invalid API Key and/or OTT (One Time Token). Provide OTT param (2nd param) or make sure `xAppToken` query param is present (Browser)");
            }
          }
        }
        if (typeof globalThis !== "undefined" && Object.keys(globalThis).indexOf("window") < 0) {
          log("Running in node");
        } else {
          console.log("XUMM SDK: Running in browser");
          this.isBrowser = true;
        }
        this.apiKey = apiKey;
        this.apiSecret = secret.uuidv4;
        if (this.jwtFlow && !this.jwt) {
          this.authPromise = new Promise((resolve) => {
            this.authPromiseResolve = resolve;
          });
          Promise.resolve().then(() => this.authorize()).catch((e) => {
            log("Authorize error:", e.message);
            if (this === null || this === void 0 ? void 0 : this.invoker) {
              this.invoker.caught(e);
            }
            if (this.authPromiseResolve) {
              this.authPromiseResolve();
            }
          });
        }
        return this;
      }
      setEndpoint(endpoint) {
        if (endpoint.match(/^http/)) {
          this.endpoint = endpoint.trim();
          return true;
        }
        return false;
      }
      authorize() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
          log("JWT Authorize", this.apiSecret);
          let store;
          if ((this === null || this === void 0 ? void 0 : this.invoker) && this.invoker.constructor === index_1.XummSdkJwt) {
            store = this.invoker._jwtStore(this, (jwt) => this.jwt = jwt);
          }
          const authorizeData = (store === null || store === void 0 ? void 0 : store.get(this.apiSecret)) || (yield this.call("authorize"));
          if ((_b = (_a = authorizeData) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.code) {
            log(`Could not resolve API Key & OTT to JWT (already fetched? Unauthorized?)`);
            if ((this === null || this === void 0 ? void 0 : this.invoker) && this.invoker.constructor === index_1.XummSdkJwt && ((_c = this === null || this === void 0 ? void 0 : this.invoker) === null || _c === void 0 ? void 0 : _c.fatalHandler)) {
              this.invoker.fatalHandler(new Error(authorizeData.error.reference));
            } else {
              utils_1.throwIfError(authorizeData);
            }
          } else if ((_d = authorizeData) === null || _d === void 0 ? void 0 : _d.jwt) {
            const JwtOttResponse = authorizeData;
            store === null || store === void 0 ? void 0 : store.set(this.apiSecret, JwtOttResponse);
          } else {
            throw new Error(`Unexpected response for xApp JWT authorize request`);
          }
          if (this.authPromiseResolve) {
            this.authPromiseResolve();
          }
        });
      }
      call(endpoint, httpMethod = "GET", data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const method = httpMethod.toUpperCase();
          const trEndpoint = endpoint.split("/")[0];
          if (this.jwtFlow && !(this === null || this === void 0 ? void 0 : this.jwt) && this.authPromise && endpoint !== "authorize") {
            yield this.authPromise;
          }
          try {
            let body;
            if (typeof data !== "undefined") {
              if (typeof data === "object" && data !== null) {
                body = JSON.stringify(data);
              }
              if (typeof data === "string") {
                body = data;
              }
            }
            const headers = {
              "Content-Type": "application/json"
            };
            if (!this.isBrowser) {
              Object.assign(headers, {
                "User-Agent": `xumm-sdk/node (${os_browserify_1.hostname()}) node-fetch`
              });
            }
            if (!this.jwtFlow) {
              Object.assign(headers, {
                "x-api-key": this.apiKey,
                "x-api-secret": this.apiSecret
              });
            } else {
              if (endpoint === "authorize") {
                Object.assign(headers, {
                  "x-api-key": this.apiKey,
                  "x-api-ott": this.apiSecret
                });
              } else {
                Object.assign(headers, {
                  "Authorization": "Bearer " + this.jwt
                });
              }
            }
            const jwtEndpoints = [
              "authorize",
              "ping",
              "curated-assets",
              "rates",
              "payload",
              "userdata",
              "xrpl-tx",
              "nftoken-detail",
              "rails",
              "hookhash"
            ];
            const endpointType = this.jwtFlow && jwtEndpoints.indexOf(trEndpoint) > -1 ? "jwt" : "platform";
            const request = yield fetch(this.endpoint + "/api/v1/" + endpointType + "/" + endpoint, {
              method,
              body,
              headers
            });
            const json = yield request.json();
            return json;
          } catch (e) {
            const err = new Error(`Unexpected response from XUMM API [${method}:${trEndpoint}]`);
            err.stack = ((_a = e) === null || _a === void 0 ? void 0 : _a.stack) || void 0;
            throw err;
          }
        });
      }
      ping() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const pong = yield this.call("ping");
          utils_1.throwIfError(pong);
          if (typeof pong.auth !== "undefined") {
            return pong.auth;
          }
          if (typeof ((_a = pong) === null || _a === void 0 ? void 0 : _a.ott_uuidv4) !== "undefined") {
            return {
              application: {
                uuidv4: pong.app_uuidv4,
                name: pong.app_name
              },
              jwtData: pong
            };
          }
          if (typeof ((_b = pong) === null || _b === void 0 ? void 0 : _b.usertoken_uuidv4) !== "undefined") {
            return {
              application: {
                uuidv4: pong.client_id,
                name: pong.app_name
              },
              jwtData: pong
            };
          }
          throw new Error(`Unexpected response for ping request`);
        });
      }
      getCuratedAssets() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("curated-assets");
        });
      }
      getRates(currencyCode) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("rates/" + currencyCode.trim().toUpperCase());
        });
      }
      getKycStatus(userTokenOrAccount) {
        return __awaiter(this, void 0, void 0, function* () {
          if (userTokenOrAccount.trim().match(/^r/)) {
            const call = yield this.call("kyc-status/" + userTokenOrAccount.trim());
            return (call === null || call === void 0 ? void 0 : call.kycApproved) ? "SUCCESSFUL" : "NONE";
          } else {
            const call = yield this.call("kyc-status", "POST", {
              user_token: userTokenOrAccount
            });
            return (call === null || call === void 0 ? void 0 : call.kycStatus) || "NONE";
          }
        });
      }
      getRails() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("rails");
        });
      }
      getHookHash(hookHash) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof hookHash === "string" && hookHash.trim().match(/^[A-Fa-f0-9]{64}$/)) {
            return yield this.call("hookhash/" + hookHash.trim());
          }
          throw Error("Invalid Hook Hash (expecting 64 char hex)");
        });
      }
      getHookHashes() {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("hookhash");
        });
      }
      getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.call("xrpl-tx/" + txHash.trim());
        });
      }
      getNftokenDetail(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.jwtFlow) {
            throw new Error("getNftokenDetail: only available in JWT (XummSdkJwt) mode");
          }
          return yield this.call("nftoken-detail/" + tokenId.trim());
        });
      }
      verifyUserTokens(userTokens) {
        return __awaiter(this, void 0, void 0, function* () {
          return (yield this.call("user-tokens", "POST", {
            tokens: Array.isArray(userTokens) ? userTokens : [userTokens]
          })).tokens;
        });
      }
      // Internal
      _inject(Invoker) {
        if (!this.injected) {
          this.invoker = Invoker;
        } else {
          throw new Error("Cannot `_inject` twice");
        }
      }
    };
    exports.Meta = Meta;
  }
});

// node_modules/xumm-sdk/dist/src/Storage.js
var require_Storage = __commonJS({
  "node_modules/xumm-sdk/dist/src/Storage.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = void 0;
    var debug_1 = require_browser();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:storage");
    var Storage = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
      }
      get() {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("app-storage", "GET");
          utils_1.throwIfError(call);
          return call.data;
        });
      }
      set(data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("app-storage", "POST", data);
          utils_1.throwIfError(call);
          return call.stored;
        });
      }
      delete() {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("app-storage", "DELETE");
          utils_1.throwIfError(call);
          return call.stored;
        });
      }
    };
    exports.Storage = Storage;
  }
});

// node_modules/es5-ext/global.js
var require_global = __commonJS({
  "node_modules/es5-ext/global.js"(exports, module) {
    var naiveFallback = function() {
      if (typeof self === "object" && self) return self;
      if (typeof window === "object" && window) return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = function() {
      if (this) return this;
      if (typeof globalThis === "object" && globalThis) return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__) return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/websocket/package.json
var require_package = __commonJS({
  "node_modules/websocket/package.json"(exports, module) {
    module.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "IÃ±aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.35",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.63",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module) {
    module.exports = require_package().version;
  }
});

// node_modules/websocket/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/websocket/lib/browser.js"(exports, module) {
    var _globalThis;
    if (typeof globalThis === "object") {
      _globalThis = globalThis;
    } else {
      try {
        _globalThis = require_global();
      } catch (error) {
      } finally {
        if (!_globalThis && typeof window !== "undefined") {
          _globalThis = window;
        }
        if (!_globalThis) {
          throw new Error("Could not determine global this");
        }
      }
    }
    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
    var websocket_version = require_version();
    function W3CWebSocket(uri, protocols) {
      var native_instance;
      if (protocols) {
        native_instance = new NativeWebSocket(uri, protocols);
      } else {
        native_instance = new NativeWebSocket(uri);
      }
      return native_instance;
    }
    if (NativeWebSocket) {
      ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop) {
        Object.defineProperty(W3CWebSocket, prop, {
          get: function() {
            return NativeWebSocket[prop];
          }
        });
      });
    }
    module.exports = {
      "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
      "version": websocket_version
    };
  }
});

// node_modules/xumm-sdk/dist/src/Payload.js
var require_Payload = __commonJS({
  "node_modules/xumm-sdk/dist/src/Payload.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Payload = void 0;
    var debug_1 = require_browser();
    var websocket_1 = require_browser3();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:payload");
    var logWs = debug_1.debug("xumm-sdk:payload:websocket");
    var maxSocketConnectAttempts = typeof jest !== "undefined" ? 0 : 30;
    var socketConnectAttemptSecondsDelay = 2;
    var socketKeepaliveSendSeconds = 2;
    var socketKeepaliveTimeoutSeconds = 10;
    var Payload = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
      }
      resolvePayload(payload) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof payload === "string") {
            return yield this.get(payload, true);
          } else if (typeof ((_a = payload) === null || _a === void 0 ? void 0 : _a.uuid) !== "undefined") {
            return yield this.get(payload.uuid, true);
          } else if (typeof ((_c = (_b = payload) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.uuid) !== "undefined") {
            return payload;
          }
          throw new Error("Could not resolve payload (not found)");
        });
      }
      create(payload, returnErrors = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const directTx = typeof payload.TransactionType !== "undefined" && typeof payload.txjson === "undefined";
          const call = yield this.Meta.call("payload", "POST", directTx ? { txjson: payload } : payload);
          if (returnErrors) {
            utils_1.throwIfError(call);
          }
          const isCreatedPayload = ((_a = call) === null || _a === void 0 ? void 0 : _a.next) !== void 0;
          if (!isCreatedPayload) {
            return null;
          }
          return call;
        });
      }
      get(payload, returnErrors = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const payloadUuid = typeof payload === "string" ? payload : payload === null || payload === void 0 ? void 0 : payload.uuid;
          const call = yield this.Meta.call("payload/" + payloadUuid, "GET");
          if (returnErrors) {
            utils_1.throwIfError(call);
          }
          const isPayload = ((_b = (_a = call) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.uuid) !== void 0;
          if (!isPayload) {
            return null;
          }
          return call;
        });
      }
      subscribe(payload, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const callbackPromise = new utils_1.DeferredPromise();
          const payloadDetails = yield this.resolvePayload(payload);
          if (payloadDetails) {
            const _u = "undefined";
            let socket;
            let keepAlivePing;
            let keepAliveReinstateTimer;
            let reconnectAttempts = 0;
            callbackPromise.promise.then(() => {
              clearTimeout(keepAlivePing);
              clearTimeout(keepAliveReinstateTimer);
              socket.close(1e3);
            });
            const connect = () => {
              var _a, _b;
              socket = typeof ((_a = globalThis) === null || _a === void 0 ? void 0 : _a.MockedWebSocket) !== _u && typeof jest !== _u ? new ((_b = globalThis) === null || _b === void 0 ? void 0 : _b.MockedWebSocket)("ws://xumm.local") : new websocket_1.w3cwebsocket(this.Meta.endpoint.replace(/^http/, "ws") + "/sign/" + payloadDetails.meta.uuid);
              socket.onopen = () => {
                console.log(`Payload ${payloadDetails.meta.uuid}: subscription active (WebSocket opened)`);
                keepAlivePing = setInterval(() => {
                  logWs("Send keepalive");
                  socket.send('{"ping":true}');
                }, socketKeepaliveSendSeconds * 1e3);
              };
              socket.onmessage = (MessageEvent) => __awaiter(this, void 0, void 0, function* () {
                reconnectAttempts = 0;
                const m = MessageEvent.data;
                let json = void 0;
                try {
                  json = JSON.parse(m.toString());
                  if ((json === null || json === void 0 ? void 0 : json.message) && json.message === "Right back at you!") {
                    logWs("Keepalive response");
                    clearTimeout(keepAliveReinstateTimer);
                    keepAliveReinstateTimer = setTimeout(() => {
                      console.log(`WebSocket for ${payloadDetails.meta.uuid} keepalive response timeout, assume dead... (Reconnect)`);
                      socket.close(1002, "Assume dead");
                    }, socketKeepaliveTimeoutSeconds * 1e3);
                    return;
                  }
                  if ((json === null || json === void 0 ? void 0 : json.signed) || (json === null || json === void 0 ? void 0 : json.expired)) {
                    const updatedPayloadDetails = yield this.resolvePayload(payload);
                    Object.assign(payloadDetails, Object.assign({}, updatedPayloadDetails));
                  }
                } catch (e) {
                  logWs(`Payload ${payloadDetails.meta.uuid}: Received message, unable to parse as JSON`, e);
                }
                if (json && callback && typeof json.devapp_fetched === "undefined") {
                  try {
                    const callbackResult = yield callback({
                      uuid: payloadDetails.meta.uuid,
                      data: json,
                      resolve(resolveData) {
                        return __awaiter(this, void 0, void 0, function* () {
                          yield callbackPromise.resolve(resolveData || void 0);
                        });
                      },
                      payload: payloadDetails
                    });
                    if (callbackResult !== void 0) {
                      callbackPromise.resolve(callbackResult);
                    }
                  } catch (e) {
                    logWs(`Payload ${payloadDetails.meta.uuid}: Callback exception`, e);
                    console.log(`Payload ${payloadDetails.meta.uuid}: Callback exception: ${e.message}`);
                  }
                }
              });
              socket.onclose = (_e) => {
                logWs("Closed [code]", _e.code);
                logWs("Closed [reason]", _e.reason);
                logWs("Closed [wasClean]", _e.wasClean);
                clearInterval(keepAlivePing);
                clearTimeout(keepAliveReinstateTimer);
                if (_e.code > 1e3 || _e.wasClean === false) {
                  console.log(_e);
                  logWs("Unhealthy disconnect, reconnecting...", _e.code);
                  if (reconnectAttempts < maxSocketConnectAttempts) {
                    if (reconnectAttempts === 0) {
                      console.log(`WebSocket for ${payloadDetails.meta.uuid} lost, reconnecting...`);
                    }
                    setTimeout(() => {
                      reconnectAttempts++;
                      logWs("# Reconnect");
                      if (typeof jest === "undefined") {
                        socket = connect();
                      }
                    }, socketConnectAttemptSecondsDelay * 1e3);
                  } else {
                    if (typeof jest === "undefined") {
                      console.log(`WebSocket for ${payloadDetails.meta.uuid} exceeded reconnect timeouts, give up`);
                    }
                  }
                } else {
                }
                logWs(`Payload ${payloadDetails.meta.uuid}: Subscription ended (WebSocket closed)`);
              };
              return socket;
            };
            socket = connect();
            return {
              payload: payloadDetails,
              resolve(resolveData) {
                callbackPromise.resolve(resolveData || void 0);
              },
              resolved: callbackPromise.promise,
              websocket: socket
            };
          }
          utils_1.throwIfError(payloadDetails);
          throw Error(`Couldn't subscribe: couldn't fetch payload`);
        });
      }
      cancel(payload, returnErrors = false) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          const fullPayload = yield this.resolvePayload(payload);
          const call = yield this.Meta.call("payload/" + ((_a = fullPayload === null || fullPayload === void 0 ? void 0 : fullPayload.meta) === null || _a === void 0 ? void 0 : _a.uuid), "DELETE");
          if (returnErrors) {
            utils_1.throwIfError(call);
          }
          const isValidResponse = ((_c = (_b = call) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.uuid) !== void 0;
          if (!isValidResponse) {
            return null;
          }
          return call;
        });
      }
      createAndSubscribe(payload, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          const createdPayload = yield this.create(payload, true);
          if (createdPayload) {
            const subscription = yield this.subscribe(createdPayload, callback);
            return Object.assign({ created: createdPayload }, subscription);
          }
          throw new Error(`Error creating payload or subscribing to created payload`);
        });
      }
    };
    exports.Payload = Payload;
  }
});

// node_modules/xumm-sdk/dist/src/JwtUserdata.js
var require_JwtUserdata = __commonJS({
  "node_modules/xumm-sdk/dist/src/JwtUserdata.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JwtUserdata = void 0;
    var debug_1 = require_browser();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:xapp:userdata");
    var validateKey = (key) => {
      if (!(typeof key === "string" && key.match(/^[a-z0-9]{3,}$/))) {
        throw new Error("Invalid key, only a-z0-9 (min three chars) allowed: " + key);
      }
    };
    var JwtUserdata = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
      }
      list() {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("userdata", "GET");
          utils_1.throwIfError(call);
          return call.keys;
        });
      }
      get(key) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const keys = Array.isArray(key) ? key.join(",") : key;
          keys.split(",").forEach((k) => validateKey(k));
          const call = yield this.Meta.call("userdata/" + keys, "GET");
          utils_1.throwIfError(call);
          return keys.split(",").length > 1 ? call.data : ((_a = call.data) === null || _a === void 0 ? void 0 : _a[keys]) || {};
        });
      }
      delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
          validateKey(key);
          const call = yield this.Meta.call("userdata/" + key, "DELETE");
          utils_1.throwIfError(call);
          return call.persisted;
        });
      }
      set(key, data) {
        return __awaiter(this, void 0, void 0, function* () {
          validateKey(key);
          const call = yield this.Meta.call("userdata/" + key, "POST", data);
          utils_1.throwIfError(call);
          return call.persisted;
        });
      }
    };
    exports.JwtUserdata = JwtUserdata;
  }
});

// node_modules/xumm-sdk/dist/src/xApp.js
var require_xApp = __commonJS({
  "node_modules/xumm-sdk/dist/src/xApp.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xApp = void 0;
    var debug_1 = require_browser();
    var JwtUserdata_1 = require_JwtUserdata();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:xapp");
    var xApp = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
        this.userdata = new JwtUserdata_1.JwtUserdata(MetaObject);
      }
      get(ott) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("xapp/ott/" + ott, "GET");
          utils_1.throwIfError(call);
          return call;
        });
      }
    };
    exports.xApp = xApp;
  }
});

// node_modules/xumm-sdk/dist/src/Push.js
var require_Push = __commonJS({
  "node_modules/xumm-sdk/dist/src/Push.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Push = void 0;
    var debug_1 = require_browser();
    var JwtUserdata_1 = require_JwtUserdata();
    var utils_1 = require_utils();
    var log = debug_1.debug("xumm-sdk:xapp");
    var Push = class {
      constructor(MetaObject) {
        log("Constructed");
        this.Meta = MetaObject;
        this.userdata = new JwtUserdata_1.JwtUserdata(MetaObject);
      }
      event(data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("xapp/event", "POST", data);
          utils_1.throwIfError(call);
          return call;
        });
      }
      notification(data) {
        return __awaiter(this, void 0, void 0, function* () {
          const call = yield this.Meta.call("xapp/push", "POST", data);
          utils_1.throwIfError(call);
          return call;
        });
      }
    };
    exports.Push = Push;
  }
});

// node_modules/xumm-sdk/dist/src/index.js
var require_src = __commonJS({
  "node_modules/xumm-sdk/dist/src/index.js"(exports) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XummSdkJwt = exports.XummSdk = void 0;
    var debug_1 = require_browser();
    var Meta_1 = require_Meta();
    var Storage_1 = require_Storage();
    var Payload_1 = require_Payload();
    var xApp_1 = require_xApp();
    var Push_1 = require_Push();
    var JwtUserdata_1 = require_JwtUserdata();
    var buffer_1 = require_buffer();
    var log = debug_1.debug("xumm-sdk");
    var XummSdk = class {
      constructor(apiKey, apiSecret) {
        log("Constructed");
        this.Meta = new Meta_1.Meta(apiKey || this.getEnv("XUMM_APIKEY"), apiSecret || this.getEnv("XUMM_APISECRET"));
        this.storage = new Storage_1.Storage(this.Meta);
        this.payload = new Payload_1.Payload(this.Meta);
        this.jwtUserdata = new JwtUserdata_1.JwtUserdata(this.Meta);
        this.Push = new Push_1.Push(this.Meta);
        this.xApp = new xApp_1.xApp(this.Meta);
        this.Meta._inject(this);
        return this;
      }
      getEnv(arg) {
        let value = "";
        try {
          value = (process === null || process === void 0 ? void 0 : process.env[arg]) || "";
        } catch (_e) {
        }
        return value;
      }
      /**
       * Proxy methods to Meta class below
       */
      ping() {
        return this.Meta.ping();
      }
      getCuratedAssets() {
        return this.Meta.getCuratedAssets();
      }
      getRails() {
        return this.Meta.getRails();
      }
      getHookHashes() {
        return this.Meta.getHookHashes();
      }
      getHookHash(hookHash) {
        return this.Meta.getHookHash(hookHash);
      }
      getRates(currencyCode) {
        return this.Meta.getRates(currencyCode);
      }
      getKycStatus(userTokenOrAccount) {
        return this.Meta.getKycStatus(userTokenOrAccount);
      }
      getTransaction(txHash) {
        return this.Meta.getTransaction(txHash);
      }
      getNftokenDetail(tokenId) {
        return this.Meta.getNftokenDetail(tokenId);
      }
      verifyUserTokens(userTokens) {
        return this.Meta.verifyUserTokens(userTokens);
      }
      verifyUserToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
          const tokenResults = yield this.Meta.verifyUserTokens([token]);
          return Array.isArray(tokenResults) && tokenResults.length === 1 ? tokenResults[0] : null;
        });
      }
      setEndpoint(endpoint) {
        return this.Meta.setEndpoint(endpoint);
      }
      caught(error) {
        throw error;
      }
    };
    exports.XummSdk = XummSdk;
    var XummSdkJwt = class extends XummSdk {
      constructor(apiKeyOrJwt, ott, options) {
        var _a, _b, _c, _d, _f, _g, _h, _j;
        let _ott = String(ott || "").trim().toLowerCase();
        const isRawJwt = apiKeyOrJwt.length !== 36;
        if (!isRawJwt) {
          if (typeof ott === "undefined" && typeof window !== "undefined" && typeof window.URLSearchParams !== "undefined") {
            const urlSearchParams = new window.URLSearchParams(((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.search) || "");
            for (const pair of urlSearchParams.entries()) {
              if (pair[0] === "xAppToken") {
                _ott = pair[1].toLowerCase().trim();
              }
            }
            if (_ott === "" && !(options === null || options === void 0 ? void 0 : options.store) && !(options === null || options === void 0 ? void 0 : options.noAutoRetrieve)) {
              if (typeof ((_b = window === null || window === void 0 ? void 0 : window.localStorage) === null || _b === void 0 ? void 0 : _b["XummSdkJwt"]) === "string") {
                try {
                  const localStorageJwtData = (_d = (_c = window === null || window === void 0 ? void 0 : window.localStorage) === null || _c === void 0 ? void 0 : _c["XummSdkJwt"]) === null || _d === void 0 ? void 0 : _d.split(":");
                  const localStorageJwt = JSON.parse((_f = localStorageJwtData === null || localStorageJwtData === void 0 ? void 0 : localStorageJwtData.slice(1)) === null || _f === void 0 ? void 0 : _f.join(":"));
                  if (localStorageJwt === null || localStorageJwt === void 0 ? void 0 : localStorageJwt.jwt) {
                    const decodedJwt = buffer_1.Buffer.from((_g = localStorageJwt.jwt.split(".")) === null || _g === void 0 ? void 0 : _g[1], "base64").toString("utf8");
                    const jwtContents = JSON.parse(decodedJwt);
                    if (jwtContents === null || jwtContents === void 0 ? void 0 : jwtContents.exp) {
                      const validForSec = (jwtContents === null || jwtContents === void 0 ? void 0 : jwtContents.exp) - Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
                      console.log("Restoring OTT " + (localStorageJwtData === null || localStorageJwtData === void 0 ? void 0 : localStorageJwtData[0]));
                      if (validForSec > 60 * 60) {
                        _ott = localStorageJwtData === null || localStorageJwtData === void 0 ? void 0 : localStorageJwtData[0];
                      } else {
                        console.log("Skip restore: not valid for one more hour");
                      }
                    }
                  }
                } catch (e) {
                  console.log("JWT Restore Error", e);
                }
              }
            }
          }
        }
        super(apiKeyOrJwt, !isRawJwt && _ott !== "" ? "xApp:OneTimeToken:" + _ott : "RAWJWT:" + apiKeyOrJwt);
        this.resolve = (ottData) => {
          log("OTT data resolved", ottData);
        };
        this.reject = (error) => {
          log("OTT data rejected", error.message);
        };
        this.ottResolved = isRawJwt ? Promise.resolve() : new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
        if (options === null || options === void 0 ? void 0 : options.fatalHandler) {
          this.fatalHandler = options.fatalHandler;
        }
        this.store = {
          get(uuid) {
            var _a2;
            log("[JwtStore] Â» Builtin JWT store GET");
            if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
              if (typeof window.localStorage["XummSdkJwt"] === "string") {
                const lsOttData = window.localStorage["XummSdkJwt"].split(":");
                if (lsOttData[0] === uuid) {
                  log("Restoring OTT from localStorage:", uuid);
                  try {
                    return JSON.parse(lsOttData.slice(1).join(":"));
                  } catch (e) {
                    log("Error restoring OTT Data (JWT) from localStorage", (_a2 = e) === null || _a2 === void 0 ? void 0 : _a2.message);
                  }
                }
              }
            }
          },
          set(uuid, ottData) {
            log("[JwtStore] Â» Builtin JWT store SET", uuid);
            if (typeof window !== "undefined" && typeof localStorage !== "undefined") {
              window.localStorage["XummSdkJwt"] = uuid + ":" + JSON.stringify(ottData);
            }
          }
        };
        if ((_h = options === null || options === void 0 ? void 0 : options.store) === null || _h === void 0 ? void 0 : _h.get) {
          this.store.get = options.store.get;
        }
        if ((_j = options === null || options === void 0 ? void 0 : options.store) === null || _j === void 0 ? void 0 : _j.set) {
          this.store.set = options.store.set;
        }
        if (isRawJwt) {
          this.reject(new Error("Not in OTT flow: in raw JWT (OAuth2-like) flow"));
          log("Using JWT (Raw, OAuth2) flow");
        } else {
          log("Using JWT (xApp) flow");
        }
      }
      _jwtStore(invoker, persistJwt) {
        if (invoker && (invoker === null || invoker === void 0 ? void 0 : invoker.constructor) === Meta_1.Meta) {
          return {
            get: (uuid) => {
              var _a;
              log("[JwtStore] Proxy GET");
              return (_a = this.store) === null || _a === void 0 ? void 0 : _a.get(uuid);
            },
            set: (uuid, ottData) => {
              var _a;
              log("[JwtStore] Proxy SET");
              this.resolve(ottData.ott);
              persistJwt(ottData.jwt);
              this.jwt = ottData.jwt;
              return (_a = this.store) === null || _a === void 0 ? void 0 : _a.set(uuid, ottData);
            }
          };
        }
        throw new Error("Invalid _jwtStore invoker");
      }
      getOttData() {
        return __awaiter(this, void 0, void 0, function* () {
          const resolved = yield this.ottResolved;
          if (resolved) {
            return resolved;
          }
          throw new Error("Called getOttData on a non OTT-JWT flow");
        });
      }
      getJwt() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ottResolved;
          return this.jwt;
        });
      }
      caught(error) {
        this.reject(error);
      }
    };
    exports.XummSdkJwt = XummSdkJwt;
  }
});
export default require_src();
//# sourceMappingURL=xumm-sdk.js.map
