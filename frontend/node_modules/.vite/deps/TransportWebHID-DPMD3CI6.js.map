{
  "version": 3,
  "sources": ["../../@ledgerhq/devices/src/hid-framing.ts", "../../@ledgerhq/hw-transport-webhid/node_modules/@ledgerhq/hw-transport/src/Transport.ts", "../../@ledgerhq/logs/src/index.ts", "../../@ledgerhq/hw-transport-webhid/src/TransportWebHID.ts", "../../@ledgerhq/devices/src/index.ts"],
  "sourcesContent": ["import { TransportError } from \"@ledgerhq/errors\";\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      sequence: number;\n    }\n  | null\n  | undefined;\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n", "import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nimport { LocalTracer, TraceContext, LogType } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n\nconst DEFAULT_LOG_TYPE = \"transport\";\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\nexport type DescriptorEventType = \"add\" | \"remove\";\n/**\n * A \"descriptor\" is a parameter that is specific to the implementation, and can be an ID, file path, or URL.\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: DescriptorEventType;\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n * Observer generic type, following the Observer pattern\n */\nexport type Observer<EventType, EventError = unknown> = Readonly<{\n  next: (event: EventType) => unknown;\n  error: (e: EventError) => unknown;\n  complete: () => unknown;\n}>;\n\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n  tracer: LocalTracer;\n\n  constructor({ context, logType }: { context?: TraceContext; logType?: LogType } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (observer: Observer<DescriptorEvent<any>>) => Subscription;\n\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeoutMs?: number,\n    context?: TraceContext,\n  ) => Promise<Transport>;\n\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(\n    _apdu: Buffer,\n    { abortTimeoutMs: _abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus: Buffer[], observer: Observer<Buffer>): Subscription {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n\n    main().then(\n      () => !unsubscribed && observer.complete(),\n      e => !unsubscribed && observer.error(e),\n    );\n\n    return { unsubscribe };\n  }\n\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\",\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK],\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\",\n      );\n    }\n\n    tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n    const response = await this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),\n      { abortTimeoutMs },\n    );\n    tracer.trace(\"Received response from exchange\");\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout?: number): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise: Promise<void> | null | undefined;\n\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl<Output>(f: () => Promise<Output>): Promise<Output> {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout,\n    });\n\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\",\n      );\n    }\n\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout,\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n\n  decorateAppAPIMethods(self: Record<string, any>, methods: Array<string>, scrambleKey: string) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string,\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"),\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context?: TraceContext) {\n    this.tracer = this.tracer.withContext(context);\n  }\n\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd: TraceContext) {\n    this.tracer.updateContext(contextToAdd);\n  }\n\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext(): TraceContext | undefined {\n    return this.tracer.getContext();\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n", "export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n", "import Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [\n  {\n    vendorId: ledgerUSBVendorId,\n  },\n];\n\nconst isSupported = () =>\n  Promise.resolve(!!(window.navigator && window.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices,\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\nexport default class TransportWebHID extends Transport {\n  device: HIDDevice;\n  deviceModel: DeviceModel | null | undefined;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel =\n      typeof device.productId === \"number\"\n        ? identifyUSBProductId(device.productId)\n        : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs: Buffer[] = [];\n  inputCallback: ((arg0: Buffer) => void) | null | undefined;\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve((this.inputs.shift() as unknown) as Buffer);\n    }\n\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n  onInputReport = (e: HIDInputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel =\n            typeof device.productId === \"number\"\n              ? identifyUSBProductId(device.productId)\n              : undefined;\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n            deviceModel,\n          });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe,\n    };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = async (apdu: Buffer): Promise<Buffer> => {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n    return b as Buffer;\n  };\n\n  setScrambleKey() {}\n}\n", "import semver from \"semver\";\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nexport enum DeviceModelId {\n  blue = \"blue\",\n  nanoS = \"nanoS\",\n  nanoSP = \"nanoSP\",\n  nanoX = \"nanoX\",\n  nanoFTS = \"nanoFTS\",\n}\n\nconst devices: { [key in DeviceModelId]: DeviceModel } = {\n  [DeviceModelId.blue]: {\n    id: DeviceModelId.blue,\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    masks: [0x31000000, 0x31010000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n  },\n  [DeviceModelId.nanoS]: {\n    id: DeviceModelId.nanoS,\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    masks: [0x31100000],\n    getBlockSize: (firmwareVersion: string): number =>\n      semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\")\n        ? 4 * 1024\n        : 2 * 1024,\n  },\n  [DeviceModelId.nanoSP]: {\n    id: DeviceModelId.nanoSP,\n    productName: \"Ledger Nano S Plus\",\n    productIdMM: 0x50,\n    legacyUsbProductId: 0x0005,\n    usbOnly: true,\n    memorySize: 1536 * 1024,\n    masks: [0x33100000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n  },\n  [DeviceModelId.nanoX]: {\n    id: DeviceModelId.nanoX,\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    masks: [0x33000000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.nanoFTS]: {\n    id: DeviceModelId.nanoFTS,\n    productName: \"Ledger Nano FTS\",\n    productIdMM: 0x60,\n    legacyUsbProductId: 0x0006,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024, // ← ↓ TODO Update with actual values\n    masks: [0x33200000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano S Plus\": DeviceModelId.nanoSP,\n  \"Nano X\": DeviceModelId.nanoX,\n  \"Nano FTS\": DeviceModelId.nanoFTS,\n};\n\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (\n  targetId: number\n): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find(({ masks }) =>\n    masks.find((mask) => (targetId & 0xffff0000) === mask)\n  );\n\n  return deviceModel;\n};\n\n/**\n *\n */\nexport const identifyUSBProductId = (\n  usbProductId: number\n): DeviceModel | null | undefined => {\n  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find((d) => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (\n  productName: string\n): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find((d) => d.id === productMap[productName]);\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: Record<string, BluetoothInfos> = {};\n\nfor (const id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = {\n        deviceModel,\n        ...spec,\n      };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = (): string[] => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (\n  uuid: string\n): BluetoothInfos | undefined => serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport interface DeviceModel {\n  id: DeviceModelId;\n  productName: string;\n  productIdMM: number;\n  legacyUsbProductId: number;\n  usbOnly: boolean;\n  memorySize: number;\n  masks: number[];\n  // blockSize: number, // THIS FIELD IS DEPRECATED, use getBlockSize\n  getBlockSize: (firmwareVersion: string) => number;\n  bluetoothSpec?: {\n    serviceUuid: string;\n    writeUuid: string;\n    writeCmdUuid: string;\n    notifyUuid: string;\n  }[];\n}\n\n/**\n *\n */\nexport interface BluetoothInfos {\n  deviceModel: DeviceModel;\n  serviceUuid: string;\n  writeUuid: string;\n  writeCmdUuid: string;\n  notifyUuid: string;\n}\n"],
  "mappings": "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",
  "names": ["_a", "log", "EventEmitter", "DeviceModelId", "semver", "_a", "id", "_a", "devices", "TransportWebHID", "__awaiter", "_this", "hidFraming"]
}
